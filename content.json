[{"title":"spring aop 使用以及代理原理","date":"2017-03-10T11:09:30.000Z","path":"2017/03/10/springaop/","text":"前言又到了紧张刺激的前言了，前一段时间整理了hashmap以及解决hash碰撞的方法，然后今天在阿里第一次面试的时候就问到了。虽然这个回答的还可以，但是我对自己还是失望的，面试问我spring和主要概念aop我知不知道。讲真的，我老早就说准备看看，而且我还看过一遍，但是就只是那么匆匆一看，没有怎么在意。果然就像考试，只有仔细认真的人才会一直取得高分。所以我今天一天都在研究spring aop。 使用场景面向切面区别于面向对象，由于琐碎的逻辑需要嵌入整体的项目框架。如果是面向对象需要在相应的对象中修改代码，这样显然很麻烦，而且琐碎的逻辑耦合在了项目中。如果使用面向切面，就可以减少耦合。通过面向切面可以不用修改原有项目代码，而是在外部找到添加代码，找到需要嵌入逻辑的地方标记好，那么运行的时候就会插入相应的代码。比如我们常用的如事务管理、安全检查、缓存、对象池管理。AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理. 实践出真知启用 Spring 对 @AspectJ 方面配置的支持12在config类中添加@EnableAspectJAutoProxy注解当启动了 @AspectJ 支持后，只要我们在 Spring 容器中配置一个带 @Aspect 注释的 Bean，Spring 将会自动识别该 Bean，并将该 Bean 作为切面 Bean 处理。 定义切面12345678910111213141516171819202122232425262728293031@Aspectpublic class TestAspect &#123; @Before(&quot;execution(* com.example.web.LoginControlller.well(..))&quot;) public void logBefore(JoinPoint joinPoint) &#123; System.out.println(&quot;logBefore() is running!&quot;); System.out.println(&quot;hijacked : &quot; + joinPoint.getSignature().getName()); System.out.println(&quot;******&quot;); &#125; @After(&quot;execution(* com.example.web.LoginControlller.well(..))&quot;) public void logAfter(JoinPoint joinPoint) &#123; System.out.println(&quot;logAfter() is running!&quot;); System.out.println(&quot;hijacked : &quot; + joinPoint.getSignature().getName()); System.out.println(&quot;******&quot;); &#125; @AfterReturning( pointcut = &quot;execution(* com.example.web.LoginControlller.well(..)))&quot;, returning= &quot;result&quot;) public void logAfterReturning(JoinPoint joinPoint, Object result) &#123; System.out.println(&quot;logAfterReturning() is running!&quot;); System.out.println(&quot;hijacked : &quot; + joinPoint.getSignature().getName()); System.out.println(&quot;Method returned value is : &quot; + result); System.out.println(&quot;******&quot;); &#125;&#125; 定义控制器1234567@RestControllerpublic class LoginControlller &#123; @RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST) public String login (@PathVariable String post) &#123; System.out.println(&quot;login() is running &quot;); return &quot;hah&quot;; &#125; 输出1234567891011logBefore() is running!hijacked : well******get() is running logAfter() is running!hijacked : well******logAfterReturning() is running!hijacked : wellMethod returned value is : well****** spring aop 的代理模式12345Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than interfaces. CGLIB is used by default if a business object does not implement an interface. As it is good practice to program to interfaces rather than classes; business classes normally will implement one or more business interfaces. It is possible to force the use of CGLIB, in those (hopefully rare) cases where you need to advise a method that is not declared on an interface, or where you need to pass a proxied object to a method as a concrete type.It is important to grasp the fact that Spring AOP is proxy-based. See Section 11.6.1, “Understanding AOP proxies” for a thorough examination of exactly what this implementation detail actually means. 这是官网对于spring aop代理的描述，这里可以看到 静态代理：使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；静态代理以 AspectJ 为代表。 动态代理：在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。Spring AOP 用的就是 动态代理 动态代理 如果目标对象实现了接口，默认会采用JDK的动态代理机制实现AOP 如果目标对象实现了接口，可以强制使用CGLIB实现AOP 如果目标对象没有实现接口，必须使用CGLIB生成代理，spring会自动在CGLIB和JDK动态代理之间切换 JDK代理只能对实现了接口的类生成代理，而不能针对类 CGLIB是针对类实现代理的，主要对指定的类生成一个子类，并覆盖其中的方法 原理解析AOP 代理其实是由 AOP 框架动态生成的一个对象，该对象可作为目标对象使用。AOP 代理包含了目标对象的全部方法，但 AOP 代理中的方法与目标对象的方法存在差异：AOP 方法在特定切入点添加了增强处理，并回调了目标对象的方法。代理类图： JDK动态代理sping aop的jdk动态代理主要基于JdkDynamicAopProxy实现源代码如下：1234567891011121314final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable &#123; ... //创建一个代理对象 @Override public Object getProxy(ClassLoader classLoader) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource()); &#125; Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this); &#125; ...&#125; 从源代码中我们可以看出这个类实现了AopProxy和InvoctionHandler接口。12345678910111213141516而这个AopProxy中只定义了两个方法。这个接口是在spring中定义的。public interface AopProxy &#123; Object getProxy(); Object getProxy(ClassLoader classLoader);&#125;这个InvocationHandler接口是在jdk中定义的，其中只有一个方法invoke。* InvocationHandler 是代理实例的调用处理程序 实现的接口* 包名可以看出使用到了反射* 每个代理实例都具有一个关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程序的 invoke 方法。package java.lang.reflect;public interface InvocationHandler &#123; //在代理实例上处理方法调用并返回结果。 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; 12345678910在JdkDynamicAopProxy中getProxy最后使用的方法是return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);这个方法是Proxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。@CallerSensitivepublic static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; ...&#125; JDK动态代理demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//接口package com.example.test;/** * Created by xiezhanghua on 2017/3/11. */public interface Student &#123; void say();&#125;//实体类package com.example.test;/** * Created by xiezhanghua on 2017/3/11. */public class StudentImpl implements Student &#123; private String name; public StudentImpl() &#123; &#125; public StudentImpl(String name) &#123; this.name = name; &#125; @Override public void say() &#123; System.out.println(&quot;my name is: &quot; + name); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;//代理工厂类package com.example.test;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * Created by xiezhanghua on 2017/3/11. */public class ProxyFactory implements InvocationHandler &#123; private Object obj; public Object createObjectProxy(Object obj) &#123; this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; StudentImpl stu = (StudentImpl) obj; Object object = null; if(stu.getName() != null) object = method.invoke(stu, args); else System.out.println(&quot;i am the proxy of student&quot; + &quot;his name is &quot; + stu.getName()); return object; &#125;&#125;//展示package com.example.test;/** * Created by xiezhanghua on 2017/3/11. */public class Test &#123; public static void main(String args[]) &#123; Student stu = (Student) new ProxyFactory().createObjectProxy(new StudentImpl()); stu.say(); Student stu2 = (Student) new ProxyFactory().createObjectProxy(new StudentImpl(&quot;xiezhanghua&quot;)); stu2.say(); &#125;&#125;//输出i am the proxy of studenthis name is nullmy name is: xiezhanghua CGLIB代理spring 使用cglib代理的类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class CglibAopProxy implements AopProxy, Serializable &#123;@Overridepublic Object getProxy(ClassLoader classLoader) &#123; ... try &#123; ... // Configure CGLIB Enhancer... Enhancer enhancer = createEnhancer(); if (classLoader != null) &#123; enhancer.setClassLoader(classLoader); if (classLoader instanceof SmartClassLoader &amp;&amp; ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123; enhancer.setUseCache(false); &#125; &#125; //设置父类 enhancer.setSuperclass(proxySuperClass); enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised)); enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE); enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader)); Callback[] callbacks = getCallbacks(rootClass); Class&lt;?&gt;[] types = new Class&lt;?&gt;[callbacks.length]; for (int x = 0; x &lt; types.length; x++) &#123; types[x] = callbacks[x].getClass(); &#125; // fixedInterceptorMap only populated at this point, after getCallbacks call above enhancer.setCallbackFilter(new ProxyCallbackFilter( this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset)); enhancer.setCallbackTypes(types); // Generate the proxy class and create a proxy instance. return createProxyClassAndInstance(enhancer, callbacks); &#125; ... protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) &#123; enhancer.setInterceptDuringConstruction(false); //设置回调函数 enhancer.setCallbacks(callbacks); return (this.constructorArgs != null ? enhancer.create(this.constructorArgTypes, this.constructorArgs) : enhancer.create()); &#125; ...&#125;&#125; 主要注意的地方就是Enhancer类的使用.在创建的时候，我们要使用一个 Enhance 类的对象，而不再是 Proxy，需要为其实例指定一个父类，也就是我们 的目标对象。这样，我们新创建出来的对象就是目标对象的子类，有目标对象的一样。除此之外，还要指定一个回调函数，这个函数就和Proxy的 invoke()类似。 总体来说，使用CGlib的方法和使用Proxy的方法差不多，只是Proxy创建出来的代理对象和目标对象都实现了同一个接口。而CGlib的方法则是直接继承了目标对象。 Enhancer 参考链接spring 官方文档spring aop使用aop设计模式natian306的专栏Enhancer链接","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"hashmap 源码分析","date":"2017-03-07T13:49:49.000Z","path":"2017/03/07/hashmap/","text":"前言我发现了，写博客什么的最有意思的时候还是写前言来的开心。反正就是瞎嗨为什么动笔。为什么写这个是因为今天面试的时候问当了下面这段代码中构造函数中的参数数是干嘛用的，问这个问题我当时很羞愧，其实有的时候自己也会去问为什么有这么多构造函数，具体应用场景是什么，然后就是没有刨根问底的精神。现在我就来刨根问底下也不晚吧，😂 所问代码可以看到构造函数中都可以传入参数 threshold：阈值，用于判断是否需要调整容量。threshold的值=”容量*加载因子” loadFactor：加载因子，通常设为0.75 HashMap源代码为例子分析Java.util.Hashtable类实现了JAVA中的哈希表，内部采用Node[]数组，每个Node均可作为链表的头，用来解决哈希碰撞。 特点 基于哈希表的 Map 接口的实现。 允许使用 null 值和 null 键。 此类不保证映射的顺序。 Node类 源码123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 构造函数12345678910111213141516171819202122232425 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;/** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 扩容通常，默认加载因子 (.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 参考资料 jdk8api jdk源码","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"}]},{"title":"几种解决hash碰撞的方法","date":"2017-03-07T12:21:27.000Z","path":"2017/03/07/hash/","text":"前言又到了胡说八道时间，今天晚上接到携程电话面试（暑期实习面试），但是我正在填写银联数据的试卷（话说我面试已经过了，只要笔试过了就可以了，然而接了个电话，gg）。为什么写这个是因为今天面试问到我如何解决hash碰撞，学习知识才是王道。 哈希碰撞哈希碰撞是不同的key通过哈希函数以后得到了相同的value值。原理图如下： 拉链法Java标准库的HashMap和HashTable基本上就是用拉链法实现的。拉链法的实现比较简单，将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。原理图如下： 步骤： 通过key算出hash值 通过hash值找到地址 如果地址为空，直接添加 如果地址不为空，插入表头 线性探测法线性探索法是最简单的解决hash碰撞的方法。他把散列表当作一个循环数组看待。原理图如下： 步骤： 通过key算出hash值 通过hash值找到地址 如果地址为空，直接添加 如果地址不为空，地址++，回到上一步，循环的顺序是0-n-1-0 双重哈希法hi=(h(key)+ih1(key))％m 0≤i≤m-1 //即di=i*h1(key) ，也就是使用两个哈希函数 再哈希法简单的点说就是如果hash函数1发生冲突就换一个hash函数2 建立公共溢出区这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表 ##参考链接blog1blog2","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"}]},{"title":"泰国游记 第一天1.16 by yuan同学","date":"2017-03-02T11:37:41.000Z","path":"2017/03/02/taiday1/","text":"第一天1.16出发时间：凌晨3：00（携程接机），40分钟抵达上海浦东国际机场，办理托运和登机牌时遇到泰国来华留学生，在候机的地方给我们推荐当地特色和美食，并且帮助我们修改行程计划。(真的超级幸运，整个旅行给我们提供了很多帮助)6：50飞机起飞，十点半到达廊曼机场；注意在机场填写出入境卡，好好保存出境卡（回国时需要）更换电话卡，一行六人分开打的士前往预定的民宿，之前看攻略说一定要by meter！,然而完全没有什么用，曼谷的出租车司机有的是办法让你的出租车费用飞起来！比如走高速，绕路…… 机场——民宿Taxi1 210TB 高速费+出租费+小费Taxi2 100TB 出租费105-没有零钱省下的5TB还好还好~~ 民宿——大皇宫Taxi1 250TB 出租费Taxi2 380TB 高速费+出租费What!? 大皇宫——-民宿Taxi1 330TB 出租费（司机不认识路，饶路，已经偏贵Taxi2 510TB 高速费+出租费+…（小剧场：我们：可以不走高速吗？走下面司机：不行！不走高速到不了！我们：……)Whaaaaaat!?只想说算你们狠!!!!午餐当地、meji牛奶下午原定行程是大皇宫。但不让进了，遗憾。外面看起来就很壮观！改成卧佛寺、拍照（国王丧期，国民祭祀）晚上考山路、酒吧（center khao saim）、小吃、砍价、买东西 教训：坑货司机，400RMB 关键词：taxi、便宜、彩色（国王颜色，待查证） 、舞蹈 餐饮中午吃的：鸡腿、牛肉串（不知道叫什么），蔬菜生的配肉和酱，这个酱好辣啊很多材料都没怎么处理，总共510B下午吃的：路边各种免费饮料，应该是国王祭祀期间送的、芒果（不是很甜100B）晚上吃的：榴莲180B（第一次吃，还挺好吃的））、热带水果拼盘50B两份（火龙果、芒果、木瓜）、pad thai50B（虾仁，加一句，这边的虾不要钱的样子，什么里面都加）、椰奶冰淇淋，有椰肉好吃的50B，酒吧各种好吃的1470B 建议：1.酒吧要选人多的，有欧洲人莫名就起舞了，很多人都会上去跳舞。泰国的酒普遍比国内贵一些。2.榴莲要选软的，颜色偏淡，饱满的，并不便宜3.曼谷check in 3点以后，自己定的民宿可以联系房东，（airbnb上预定的）4.建议住民宿，房东让我们早check in，让我们寄存东西，免费送我们去机场，常常受到我们的电话骚扰。泰国人十分守时，一般只会提前到，所以有拖延症的小伙伴要提前准备。5.司机巨坑，建议能不上高速就不上高速，过高速的费用都是我们出（有点贵🌚），建议接机和包车6.大皇宫8:30-3:30，我们去的时候太晚了，没办法去大皇宫，很遗憾7.国际航空挺稳定，位子也还挺宽的。泰国国内航空位子窄。8.大皇宫那边有专门的志愿者帮助你找路和提供线路建议。不要听信路边收费的旅行指导。 故事1.老夫妻的舞蹈2.护照丢失奇案，主人公（汪小明）","tags":[{"name":"travel","slug":"travel","permalink":"http://yoursite.com/tags/travel/"},{"name":"thailand","slug":"thailand","permalink":"http://yoursite.com/tags/thailand/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"二叉查找树","date":"2017-03-02T10:46:02.000Z","path":"2017/03/02/TreeMap/","text":"前言本来是准备了解下HashMap特点的，最后又看到源码，然后就想知道底层原理是什么。发现又遇到了红黑树这个概念，以前一直有遇到，但是每次看了一点点就放弃了。有句话不是说：今生的是一个回首是因为上辈子500次插肩而过。我得到的结论就是如果想撩到自己喜欢的妹子，那就要多几次插肩而过，所以我决定和二叉查找树，多联络联络感情。😂😂😂 特点：二叉查找树满足按序搜索的性质，即对于树中的每个节点X，所有在X左子树中的元素的键值都比X的键值小，所有在X右子树中元素的键值逗逼X的键值要大。 操作 find：从根开始，根据比较的结果，走左分支或右分支 findMin操作时只要有左孩子就搜索左分支，findMax也是类似。 remove操作时很困难的，因为非叶子结点奖树连接在一起，而我们不希望断开这棵树 如果一个结点只有一个孩子，通过让它的父节点跳过它来删除它。 删除一个具有两个孩子的节点，只要用它右子树中最小的项来代替它。然后删除原来的右子树的最小节点。 TreeMap特点： 实现了red 实现了red-black树结构。 查找、插入和删除的时间复杂度是 $log\\left ( n \\right )$。 TreeMap 对象这方面比BinSearchTree对象高级，与AVLTree对象不相上下。 元素按照键的顺序存储。 红黑树 （red-black-tree）参考书籍《数据结构和java集合框架》","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"Tree","slug":"Tree","permalink":"http://yoursite.com/tags/Tree/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"java 算法 （搜索算法 二分排序）","date":"2017-02-28T12:30:19.000Z","path":"2017/02/28/searchAlgorithm/","text":"二分搜索算法二分搜索算法顾名思义就是每次分成两边的搜索算法，这个算法的要求是数据已经是排序过的数据。 步骤 排序 比较中值和搜索值大小，化分搜索范围 对划分的范围继续搜索 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** 不是迭代的二分搜索算法 */public static int binarySearch(int[] arr, int low, int high,int search) &#123; System.out.println(&quot;&quot;); while (low &lt;= high) &#123; int mid = (low + high) / 2; if (search &gt; arr[mid]) &#123; low = mid + 1; System.out.println(&quot;mid: &quot; + mid + &quot;high: &quot; + high + &quot;low: &quot; + low); &#125; else if (search &lt; arr[mid]) &#123; high = mid - 1; System.out.println(&quot;mid: &quot; + mid + &quot;high: &quot; + high + &quot;low: &quot; + low); &#125; else &#123; System.out.println(&quot;找到的数据在第&quot; + mid + &quot;值为：&quot; + arr[mid]); return arr[mid]; &#125; &#125; System.out.println(&quot;无此数据&quot;); return -1;&#125;/** 二分迭代搜索算法 */public static int binaryItratorSearch(int[] arr, int low, int high, int search) &#123; System.out.println(&quot;&quot;); if (low &lt;= high) &#123; int mid = (low + high) / 2; if (search &lt; arr[mid]) &#123; high = mid -1; System.out.println(&quot;mid: &quot; + mid + &quot;high: &quot; + high + &quot;low: &quot; + low); binaryItratorSearch(arr, low, high, search); &#125; else if (search &gt; arr[mid]) &#123; low = mid + 1; System.out.println(&quot;mid: &quot; + mid + &quot;high: &quot; + high + &quot;low: &quot; + low); binaryItratorSearch(arr, low, high, search); &#125; else &#123; System.out.println(&quot;找到的数据在第&quot; + mid + &quot;值为：&quot; + arr[mid]); return arr[mid]; &#125; &#125; System.out.println(&quot;无此数据&quot;); return -1;&#125;","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"java 面试遇到的问题","date":"2017-02-28T04:56:15.000Z","path":"2017/02/28/javaPaper/","text":"前言：突然发现我现在写blog喜欢写些原因，最近有可能是在图书馆听着民谣，效率更高吧。我写这个就是想着把自己面试遇到的一些小问题整理下，方便自己以后看看，以方便以后别人面试的时候遇到。 java 初始化块、静态初始化块、构造函数初始化理解Java中的类初始化 static 关键字 当声明一个事物为static时，就意味着这个域或方法不会与包含它的类的任何对象实例关联在一起。 即使从未创建某个类的任何对象，也可以调用其static方法或访问其static域 equals 和 ==在Object中，使用equals方法和使用“==”运算符是完全等价的，不过许多类重写了Object类的equals方法，String类也是如此。重写后比较的是值而不是地址。 注意： String类是不可变的，String类一旦创建久不可改变。 String类采用字符串常量池是合理的，因为String是非可变的，即使多个引用指向同一个String对象，也不会导致一份对象改变影响另外的对象。 使用String类的场景：在字符串不经常变化的场景中可以使用String类，例如常量的声明、少量的变量运算。 使用StringBuffer类的场景：在频繁进行字符串运算（如拼接、替换、删除等），并且运行在多线程环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装。 使用StringBuilder类的场景：在频繁进行字符串运算（如拼接、替换、和删除等），并且运行在单线程的环境中，则可以考虑使用StringBuilder，如SQL语句的拼装、JSON封装等。 public static void main(String[] args)这样定义的原因 public main方法在程序启动的时候有jvm调用，所以应声明为public static 静态方法，方法被调用，要么使用对象实例引用访问，要么声明为static，使用类直接调用。main方法声明为static这样就无需生成对象实例，直接使用jvm调用。 void 无返回类型 String[] args 用户输入参数 java 8种基本数据类型 byte 字节型 8位 char 字符型 16位 short 短整型 16位 int 整型 32位 long 长整型 64位 float 浮点型 32位 double 双浮点型 64位 boolean 布尔型 true false 包装类 拆装箱问题java中的基本数据类型不是对象，因为这些数据使用简便，如果作为对象处理，每次使用都需要在堆上分配空间，然后在不需要的时候由垃圾回收器来清理，会照成很大的资源浪费。 解决的是将基本数据类型和包装类的转换。1234567891011121314151617181920212223HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); // HashMap&lt;String, int&gt; map = new HashMap&lt;String, int&gt;(); 会报错误map.put(&quot;test1&quot;, 11);map.put(&quot;test2&quot;, 12);for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; System.out.println(&quot;key:&quot; + entry.getKey() + &quot; value:&quot; + entry.getValue());&#125;long t = System.currentTimeMillis();Long sum = 0L;for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum += i;&#125;System.out.println(&quot;total:&quot; + sum);System.out.println(&quot;processing time: &quot; + (System.currentTimeMillis() - t) + &quot; ms&quot;);long t1 = System.currentTimeMillis();long sum1 = 0L;for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum1 += i;&#125;System.out.println(&quot;total:&quot; + sum1);System.out.println(&quot;processing time: &quot; + (System.currentTimeMillis() - t1) + &quot; ms&quot;); java 流InputStream OutputStream 8位 操作二进制数据Reader Writer 16位 以Unicode字符为单位从stream读取或往stream写入InputStreamReader 将InputStream转换为ReaderOutputStreamWriter 将OutputStream转换为Writer1.标准输入输出 2.文件操作 3.网络上数据流 4.字符串流 5.对象流 6.zip文件流 blog 参考资料《java编程思想》《细说java》jdk8知乎","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"初步接触jvm","date":"2017-02-27T10:42:49.000Z","path":"2017/02/27/jvm/","text":"ps：本来最近在弄nginx方面的东西，结果接到了SAP的电话面试，面试的java方面的知识，感觉自己对于jvm方面的知识了解有限，所以决定学习下jvm，刚好前段时间看到了《初探java虚拟机》这本书，那么接下来的学习笔记基本是以这本书为材料。 虚拟机的基本结构 虚拟机架构类加载子系统负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。方法区还存放运行时常量池信息，包括字符串字面量和数字常量。 java堆在虚拟机启动的时候建立，它是java程序最重要的内存工作区域。几乎所有的实例都放在java堆中。堆空间是线程共享的，这是一块与java应用密切相关的内存区间。 java的NIO库允许java程序使用直接内存。直接内存是在java堆外的、直接向系统申请的内存空间。通常直接内存的速度会优于java堆。由于直接内存在java堆外，因此它的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给的最大内存。 垃圾回收系统是java虚拟机的重要组成部分，垃圾回收器可以对方法区、java堆和直接内存进行回收。其中，java堆是垃圾收集器的工作重点。和c/c++不同，java中所有的对象空间释放都是隐式的。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成java堆、方法区和直接内存的全自动化管理。 每一个java虚拟机线程都有一个私有的java栈。一个线程的java栈在创建的时候被创建。java栈中保存着局部变量、方法参数，同时和java方法的调用、返回密切。 本地方法栈和java栈非常相似，最大的不同在于java栈用于java方法的调用，而本地方法栈则用于本地方法调用。作为对java虚拟机的重要扩展，java虚拟机允许java直接调用本地方法（通常使用c编写）。 PC(program counter)寄存器也是每个线程私有的空间，java虚拟机会为每一个java线程创建PC寄存器。在任意时刻，一个java线程总是在执行一个方法，这个正在执行的方法成为当前方法。如果当前方法不是本地方法，pc寄存器就会指向当前正在执行的指令。如果当前方法是本地方法，那么pc寄存器的值就是undefined。 执行引擎室java虚拟机的核心组件之一，负责执行虚拟机的字节码。 函数调用：出入java栈 java栈是一块私有的内存空间。可以说java堆和程序数据密切相关，java栈是和线程执行相关的。先入先出的结构，函数返回的时候，栈帧从java栈中弹出。 提示：由于每次函数调用都会生成对应的栈帧，从而占用一定的栈空间，因此，如果请求的栈深度大于最大可用栈深度时，系统就会抛出stackoverflowerror栈溢出的问题。 局部变量表局部变量表时栈帧的重要组成部分。用于保存函数的参数以及局部变量。局部变量只在当前函数中有效，当函数调用结束以后，随着函数栈帧的销毁，局部变量也会随之销毁。只要局部变量表中直接或间接引用的对象都是不会回收的。因此，理解局部变量表对理解垃圾回收有一定帮助。 Class文件结构 文件以一个4字节的Magic开头，紧跟着两个大小版本号 在版本号之后是常量池，常量池的个数位constant_pool_count。 常量池之后是类的访问修饰符、代表自身类的引用、父类引用以及接口数量和实现的接口引用。 在接口之后，有字段数量和字段描述、方法数量以及方法描述。 最后放着类文件的属性信息。 注意：高版本的java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的java虚拟机不能执行高版本编译器生成的Class文件。 参考书籍《初探Java虚拟机》","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}]},{"title":"nginx","date":"2017-02-27T07:29:54.000Z","path":"2017/02/27/nginx/","text":"前段时间买了一个阿里云服务器，由于是学生特价，还挺实惠的。然后过年期间就一直没去弄他，备案也差最后照相没去弄，找个时间把这个弄了。所以想着可以玩玩服务器，这段时间没怎么接错linux方面的知识，刚好借助这个机会熟悉下。拿到服务器，开始的时候是一脸萌比的，里面什么都没有，所以需要自己安装相应的软件。 第一步 远程登录参考blog阿里帮助文档使用iterm2 在本地配置好了，就可以ssh免密登陆到阿里云服务器了。 第二步 安装 nginx步骤12345678* yum -y install nginx* /etc/init.d/nginx start 这个地方会报错，nginx：nginx: [emerg] socket() [::]:80 failed (97: Address family not supported by protocol)解决方案： * vim /etc/nginx/conf.d/default.conf * 注释 [::]:80 default_server* /etc/init.d/nginx restart* 访问ip 第三步，nginx 配置文件构成1234567891011121314151617181920......events&#123;......&#125;https&#123;...... server &#123; ...... &#125; server &#123; ...... &#125; ......&#125; 第四步 nginx 压缩输出配置1234567891011121314151617181920gzip on 开启gzip模块gzip_buffers number size 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。gzip_min_length 设置允许压缩的页面最小字节流，建议大于1K压缩。gzip_http_version 1.0| 1.1 是别http版本gzip_proxied [off|expired|no-cache|no-store...] nginx作为反向代理的时候启用开启或关闭后端服务器返回的结果。gzip_type mime-type 匹配mime类型进行压缩demohttp&#123;include conf/mime-type;gzip on;gzip_min_length 1000;gzip_buffers 4 8K;gzip_http_version 1.1;gzip_type text/plain application/x-javascript text/css text/html application/xml;......&#125; 第五步 nginx 的浏览器本地缓存设置12345678location ~ .*/.(git | jpg | jpeg | png | bmp | sef)$&#123; expires 30d;&#125;location ~ .*/.(js | css)?$&#123; expires 1h;&#125; 参考资料《实战Nginx》《Nginx Http server》","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"java 算法 （排序算法 快速排序）","date":"2017-02-24T05:44:19.000Z","path":"2017/02/24/quickSort/","text":"ps:今天听了一首感动死我的歌，歌曲名是Bressanone（布列瑟农），听的时候全身鸡皮疙瘩都起来了，然后我就去搜这首歌，谁知道还有一个感人的故事。以下是作者自述，链接来着一个音乐推荐网站音乐链接 快速排序（Quick Sort）听着音乐差点都忘记了主题了，这篇blog的主题是快速排序。 思想：快速排序由C.A.R.Hoare （1962）开发的，算是分治算法的一种。该算法在数组中选择一个主元（pivot）的元素将数组分为两部分，使得第一部分中所有元素都小于或等于主元，而第二部分中的所有元素都大于主元。对第一第二部分递归调用。步骤： 取pivot 划分两部分 递归调用划分方法 具体代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** 快速排序*/public static void quickSort(int[] arr) &#123; System.out.println(&quot;&quot;); System.out.println(&quot;快速排序前的数组为： &quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125; quickSort(arr, 0, arr.length - 1); System.out.println(&quot;&quot;); System.out.println(&quot;快速排序后的数组为：&quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125;&#125;private static void quickSort(int[] arr, int first, int last) &#123; if (last &gt; first) &#123; int pivot = partition(arr, first, last); quickSort(arr, first, pivot - 1); quickSort(arr, pivot + 1, last); &#125;&#125;private static int partition(int[] arr, int first, int last) &#123; int pivot = arr[first]; // 主元 int low = first + 1; int high = last; while (high &gt; low) &#123; while (low &lt;= high &amp;&amp; arr[last] &lt;= pivot) &#123; low++; &#125; while (low &lt;= high &amp;&amp; arr[high] &gt; pivot) &#123; high--; &#125; if (high &gt; low) &#123; int temp = arr[high]; arr[high] = arr[low]; arr[low] = temp; &#125; &#125; while (high &gt; first &amp;&amp; arr[high] &gt;= pivot) &#123; high--; &#125; if (pivot &gt; arr[high]) &#123; arr[first] = arr[high]; arr[high] = pivot; return high; &#125; else &#123; return first; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455马修·连恩—布列瑟农谢谢你的评论，现在给你自己冲杯热茶，坐好，我接下来给你说个关于bressanone的故事......几年前，我疯狂地爱上了一个年轻的女孩，还有，也爱上了南部蒂罗尔山区，它在意大利的北部，与奥地利接壤，就在勃伦尔山脉的南边（勃伦尔山脉正好把意大利和奥地利分隔开来）。南部蒂罗尔曾经跟北部蒂罗尔（现在属于奥地利）和西部蒂罗尔（现在属于瑞士）是一个整体。这个地区的人说的是德国的一种方言，但是由于蒂罗尔被分割开来，而南部蒂罗尔变成意大利的一部分，所以这里的地名一般都有意大利文和德文两种名字。总之呢...许多年前我给绿色和平组织工作，在那时候我遇上了一个让我心动的女孩子。我们是在加州的约塞米蒂国家公园归途中相遇的。自那以后，她回到科罗拉多州的绿色和平组织，最后回到纽约洲去上学，而我则回到圣迭戈的绿色和平组织，并且最后回到我在加拿大育空地区的老家。此后的几个月里我们不停地通讯。很快我们都希望能有更进一步的发展。她将要去意大利的佛罗伦萨学习艺术，我就要去德国的慕尼黑开始新的表演生活，跟一支叫“三月粉”的摇滚乐队...哈啊，没错，三月粉...那是另外一个故事了。当我俩都在欧洲的时候，我们选了一个处在佛罗伦萨和慕尼黑之间的地方约会。这就是南部蒂罗尔的一个小镇，德文里面它叫“Brixen”，意大利文就是“bressanone”。Bressanone是个非常优美的小镇。它被小乡村包围着，而山谷中回响着教堂的钟声，山羊在牧场漫步，远处是高耸的白色山头。我们在那里玩乐了几天，探索过周围的小乡村，还有彼此的心。离别的日子到了，她要回去的时候我陪着她去附近乡村的火车站，真是很令人沮丧啊，我们都要踏上各自的道路。流着泪水，我上了去火车站的公共汽车，在短短的40分钟路程里，我缓缓入睡了，在梦中，我隐隐约约地似乎听到了这样的一首歌，非常美妙的旋律和歌词。我醒来的时候，赶紧下了车，来到最近的咖啡店，把所听到的旋律和歌词写在一张餐巾纸上，好让我能够永远地记住它。一年以后，我才有机会把这首歌录下来。在我的心里，永远会留个地方是给她，还有那些小乡村，和这首歌。谢谢你这么认真地听我说。现在...是时候跟你同睡了，晚安!!!:-)马修附原文：The Storyby Matthew LienDate: 02-20-02 18:10Hello Forrest,Thank you for your comments. Now make yourself a cup of hot tea, sit back, and I&apos;ll tell you a story about Bressanone...Several years ago, I fell deeply in love with a young woman, and also with a part of northern Italy known as South Tyrol. It borders Austria, just south of the Brenner mountain pass which separates Italy from Austria.South Tyrol used to be joined with North Tyrol (now a part of Austria) and West Tyrol (now a part of Switzerland). The people of this area speak a dialect of German. But since Tyrol was divided and South Tyrol became a part of Italy, all the place names are in both German and Italian.Anyway... I once worked for Greenpeace many years ago, where I met a young woman who melted my heart. We met while on a retreat in California&apos;s Yosemite National Park. After the retreat, she returned to the Colorado Greenpeace office, and eventually went back to school in New York state. I returned to the San Diego Greenpeace Office, and eventually went back to my home in the Yukon, Canada.Over the months we stayed in touch. Soon we discovered that we would both be close again. She was going to study art in Florence, Italy, and I was going to live in Munich, Germany performing with a rock band called &quot;Marching Powder&quot;... ahhhh yes, Marching Powder... but that&apos;s another story.When we were both in Europe, we made arrangements to meet in a place that was close to being between Florence and Munich. This was the South Tyrolian town called &quot;Brixen&quot; in German, or &quot;Bressanone&quot; in Italian. Bressanone is a beautiful town surrounded by small villages high in the mountain valleys with churches ringing and sheep in the meadows, and the awesome peaks of the Dolomite mountains towering beyond.We spent several days exploring the mountain villages and each other&apos;s hearts. And when the day came for her to return, I took her to a train station in a nearby village, and we said goodbye. It was very sad to be going our own ways again. With tears in my eyes, I got on a bus and headed for the train station in Bressanone. During the short 40-minute bus ride, I fell asleep. And while I slept, I had a dream in which I could hear this song, complete with the words and music. When I awoke, I got off the train and went to the nearest coffee shop to write the words and music on a napkin, so I would not forget.It was years later when I finally recorded the song. I will always have a place in my heart for her... and for that village... and for this song.Thank you for listening. Now... off to bed with you!!!:-)Matthew 参考链接故事","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"java 算法 （排序算法 冒泡排序）","date":"2017-02-23T15:02:39.000Z","path":"2017/02/23/javahigh/","text":"题外话 ps:今天真的是被git弄的稀里糊涂了一天，弄到现在还在实验室，我都怀疑自己的认真劲头了😂。 以前觉得自己没有做技术的耐性，无法静静的呆在自己的电脑前。那个时候坐在电脑前都会流眼泪，那个时候就对自己说：是的我不合适做技术，然而读研的路上感觉自己的性格改变了很多，不敢说非常踏实，但是目前来说，静静地看着技术文档和书籍，常常能获得快感，就像现在已经过了12点，我在“奋笔疾书”。解决bug的时候有那么一丝丝成就感，不知道是不是自己越来越适合做技术了，感觉自己每天过的越来越充实和快乐，只要今天的自己比昨天的自己更强大。 正题 排序算法 分类 交换排序 冒泡排序 快速排序 选择排序 选择排序 堆排序 插入排序 插入排序 shell排序 合并排序 冒泡排序（Bubble Sort）思想：冒泡排序需要遍历多遍数组，在每次遍历🀄比较相邻的元素。较小值像“气泡”一样上浮，较大的值沉向底部。步骤： 对数组中的各个数据，依次比较相邻的两个数据大小 如果前面的数据大于后面的数据，就交换两个数据。这样可以找出最小的。 依次用同样的方法，排序。时间：$\\dfrac {n\\left( n-1\\right) } {2}=O\\left( n^{2}\\right)$ 123456789101112131415161718192021222324252627282930313233主要代码：package sort;import UtilAlgorithm.Main;import UtilAlgorithm.Util;/** * Created by xiezhanghua on 2017/2/23. */public class Sort &#123; public static int[] bubleSort(int[] arr) &#123; System.out.println(&quot;冒泡排序前的数组为：&quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; System.out.println(&quot;&quot;); System.out.println(&quot;冒泡排序后的数组为：&quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125; return arr; &#125;&#125; 参考书籍和链接 《java 常用算法手册》 《java 语言程序设计》","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"开发中的bug","date":"2017-02-22T05:40:48.000Z","path":"2017/02/22/bug/","text":"问题：解决maven 更新慢的问题系统：Mac解决方向：使用阿里镜像方法： cd /usr/local/Cellar/maven/3.3.9/libexec/conf(brew install maven 的路径) subl setting.xml (subl 在这里是使用sublime text 打开 文件 open -a ) 将下面代码替换setting.xml中的 mirrors 1234567891011121314151617181920&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 参考链接blog1 hexo 中写数学公式 Latexps:今天本来是准备动手看算法方面的东西，然后准备使用hexo看下数学公式怎么显示。然后就出现问题了，显示的时候会出现很多莫名的问题。重要的是我都没有数学编辑器，😂话说论文也要写了啊。所以开始找个好一点的数学编辑器，然后在b呼中找到了。那么问题来了，是时候写一篇练习Latex的文档了。 submlim + Latexb呼推荐解决方法：就是把主题中的配置文件中的 mathjax: true 设置为true","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"数据库学习笔记一","date":"2017-02-19T14:45:29.000Z","path":"2017/02/19/transction/","text":"连接查询连接是把不同表的记录连到一起的最普遍的方法。 内连接：最普遍的连接类型，而且是最匀称的，因为它们要求构成连接的每一个部分的每个表匹配，不匹配的行将被排除。 外连接：使用outer join关键字将两个表连接起来。外连接生成的结果集不仅包括符合链接条件的行数据，而且还包括左表（左外连接）、右表（右边连接时的表）或两边链接表（全外连接时的表）中所有的数据行。 合并查询合并查询结果是将多个select语句的查询结果合并在一起。因为某种情况下，需要将几个select语句查询出来的结果合并起来显示。合并查询结果使用union和union all关键字。union关键字是将所有的查询结果合并在一起，然后去除相同记录；而union all关键字则只是简单地将结果合并在一起。 索引我们常见的数据库系统，其索引使用的数据结构多是B-Tree或者B+Tree。例如，MsSql使用的是B+Tree，Oracle及Sysbase使用的是B-Tree。所以在最开始，简单地介绍一下B-Tree。B-Tree 概念：索引是对数据库表中一个或多个列的值进行排序的结构。优点：在查询过程中使用索引，会提高数据库查询效率，应用索引来查询数据库中的内容，可以减少查询的次数，从而到达查询优化目的。缺点：创建索引和维护需要耗费时间，并且该耗费时间与数据量的大小成正比；另外，索引需要占用物理空间，给数据的维护造成很多麻烦。 索引分类 普通索引：不应用任何约束的索引，该索引可以在任何数据类型中创建。 唯一索引：使用UNIQUE参数可以设置唯一索引。该索引值必须唯一。主键是一种特殊的唯一索引。 全文索引：全文索引智能创建在CHAR、VARCHAR或者TEXT类型的字段上。查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。 单列索引：单列索引只对应一个字段的索引。 多列索引：在表的多个字段上创建一个索引。 事务处理 概念和技术事务处理系统的基本抽象：现实的状态通过一个称为数据库的抽象表示，现实状态的转变通过执行一个称为事务的执行过程来反映，他改变数据库的状态。P1 这里在介绍下事务的概念以及事务的ACID特性数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。ACID 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。 参考书籍和链接《事务处理 概念和技术》《Mysql快速入门》详解SQL Server连接（内连接、外连接、交叉连接）索引","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"事务处理","slug":"事务处理","permalink":"http://yoursite.com/tags/事务处理/"}]},{"title":"数据库学习笔记二","date":"2017-02-19T14:45:29.000Z","path":"2017/02/19/mysql2/","text":"Mysql 视图概念： 视图可以包含表中的所有列，或者仅包含选定的列。视图可以创建自一个或者多个表，这取决于创建该视图的 SQL 语句的写法。视图，是一种虚拟的表，数据库只存放了视图的定义，并没有存放视图中的数据。优点：用户可以不用看到整个数据库表中的数据，而只关心对自己有用的数据即可。 作用： 简单性：所见即所需 安全性：授权 逻辑数据独立性：程序与数据库独立 视图与查询的区别： 视图和查询都是用由sql语句组成,这是他们相同的地方,但是视图和查询有着本质区别：它们的区别在于： 存储上的区别：视图存储为数据库设计的一部分,而查询则不是 更新限制的要求不一样要注意：因为视图来自于表,所以通过视图可以间接对表进行更新,我们也可以通过update语句对表进行更新,但是对视图和查询更新限制是不同的, 排序结果：通过sql语句,可以对一个表进行排序,而视图则不行。 Mysql 存储过程存储过程和存储函数是一些被用户定义的SQL语句集合，经编译后存储在数据库。用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。其具有执行速度快，提高系统性能，确保数据库安全等诸多优点。 优点： 存储过程允许标准组件式编程 存储过程能够实现较快的执行速度 存储过程能够减少网络流量 存储过程可被作为一种安全机制来充分利用 参考书籍和链接《Mysql快速入门》博客一博客二","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"学习资料记录","date":"2017-02-17T06:31:59.000Z","path":"2017/02/17/reading/","text":"这里记录下每个阶段的学习资料 ##java 多线程和并发java 并发性和多线程并发编程网JDK8JDK6 @SpringBootApplication的使用 mysql 忘记 root 密码 数据库《Mysql快速入门》 纸质书籍《事务处理的技术和概念》 这个学习的文档使电子书籍《java编程思想》 纸质书籍","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"reading","slug":"reading","permalink":"http://yoursite.com/tags/reading/"}]},{"title":"泰国游记原稿","date":"2017-02-07T03:11:48.000Z","path":"2017/02/07/thailand01/","text":"ps：最近在忙于学业，就一直没有整理我的游记，这里先贴出来一些原始稿件，对大家有帮助 泰国游记 第一天1.16故事附加：泰国留学生抵达（廊曼机场）午餐当地、meji牛奶下午卧佛寺、拍照（国王丧期，国民祭祀）晚上考山路、酒吧（center khao saim）、小吃、砍价、买东西教训：坑货司机，400RMB关键词：taxi、便宜、彩色（国王颜色，待查证） 、舞蹈中午吃的：鸡腿、牛肉串（不知道叫什么），蔬菜生的配肉和酱，这个酱好辣啊很多材料都没怎么处理，总共510B下午吃的：路边各种免费饮料，应该是国王祭祀期间送的、芒果（不是很甜100B）晚上吃的：榴莲180B（第一次吃😂😂，还挺好吃的））、热带水果拼盘50B两份（火龙果、芒果、木瓜）、pad thai50B（虾仁，加一句，这边的虾不要钱的样子，什么里面都加）、椰奶冰淇淋，有椰肉好吃的50B，酒吧各种好吃的1470B建议：1.酒吧要选人多的，有欧洲人莫名就起舞了😂😂2.榴莲要选软的，颜色偏淡，饱满的3.曼谷check in 3点以后，自己定的民宿可以联系房东，（airbnb上预定的）4.建议住民宿，房东让我们早check in，让我们寄存东西，免费送我们去机场，常常受到我们的电话骚扰。5.司机巨坑，建议能不上高速就不上高速，过高速的费用都是我们出（有点贵🌚），建议接机和包车6.大皇宫8:30-3:30，我们去的时候太晚了，没办法去大皇宫，很遗憾😭😭😭7.国际航空挺稳定，位子也还挺宽的。泰国国内航空位子窄。故事1.老夫妻的舞蹈2.护照丢失奇案，主人公（汪小明） 第二天1.17去机场：100B出行：门口出租都是一口价，不打表，我们包车SUV（260B到酒店）建议：1.正规酒店2点check in，（携程上预定的）可以寄存在东西，用护照。提前check in收费400泰铢2.虫子多3.吃饭4.中午清曼寺，静坐参悟，融入5.check in6.lila按摩店押金600B7.各种寺庙8.坐车到瓦洛洛市场（垃圾）120B草莓150B、菠萝65B、香肠15B9.坐车到苏打曼市场（100B）10.晚饭酒109B，烧烤400B，饭530B11.坐车回酒店150B12.吹风机押金300B袁枫林和陶轩 1.18地点：清迈1.接车到蝴蝶园2.蝴蝶园到激流勇进（很好玩）3.激流勇进照片，工作人员拍（150一张），建议带两套衣服包括内裤，做好防晒，这边711美好的防晒，去boots买4.午餐，自助餐（水好喝，蔬菜沙拉好吃，强推，味道极好一点涩味都没有，超级爽口），套餐内5.骑大象（没什么意思）6.丛林飞跃（19），很好玩，工作人员会拍照，出门在外记得熬pose（150一张），记得带u盘，可以拷贝7.竹筏超级无聊，还要求小费建议：1.5:00小卖部关门，这边游玩身体很渴2.防晒 早饭：157B晚饭：2550B故事：营救翻船救人，路上混战（champion被围攻，就是我们🙈）goodteam陶轩、老张尿尿在佛祖旁边梗：老司机（xzh）老妈妈（wm，老张）漂酿（袁枫林，zqr）小女孩问（xzh）性别袁枫林裤子开档（被汪明拧坏的 1.19地点：清迈1.早饭：泡面便宜又好吃，红色的味道有点怪159B2.双条车包车到双龙寺门票（50B）电梯20B，30B门票，花和蜡烛（20B）3.午餐：780B4.清迈大学，车票60B5.塔佩门shop336元加6.包车付钱：1400B7.飞机清迈～曼谷，曼谷～普吉（一路跑步）故事：祈祷汪明求签差点误机液体太重不能上飞机（托运）飞奔的✈️ 1.201.6:20起床坐车去斯米兰岛（一日游团）飞猪上订的2.岛上交通基本走环岛线路，从机场到酒店以及九点到机场都要将近2小时（刚好补觉了）3.建议：跟团不错，就是常遇到中国人😂😂，比如你在车上睡觉，她在看喜羊羊与灰太狼🌚（山寨机的外音无解）4.早餐自助，就餐后吃晕船药，会发药和黄色橡胶圈（队伍标志，靠这个区分）5.登船去斯米兰岛，斯米兰岛9岛，我们玩4个岛，两个浮潜点（7、4）先去主岛，那边吃午饭可以在间隙拍照，海水很蓝，风景很好再去第一个浮潜点7，有很多漂亮的鱼（强推）建议记得带防水套，防水套，防水套。时间半小时然后去第二个浮潜点4，没什么东西看，时间半小时最后在岛上，会给1个半小时拍照时间，岛上风景超级美，海水比第一个海蓝岛上人多，建议在船离开案边间隙拍照，宽阔海景一览无遗。1个半小时拍照时间江西冷：low，衣服750B晚饭：2150B建议：1.带毛巾、泳裤、换洗衣服裤子。每去一个岛船员都会给我们水果和饮料，最后还有饼干。船员消费是每个人50B。 1.211.早上8:15出发到码头2.坐船半小时到岛珊瑚岛3.岛上玩香蕉船还可以（800B），飞伞（800B），同学说不好玩，吃午饭，玩水4.坐船去皇权岛深潜（2100B）或者套餐，好玩，海底拍照，租相机（2000B）两人5.钓鱼，日落。6.晚餐故事：袁和周半夜买药，感动）T_T美人鱼沙雕 1.221.普吉—曼谷2.美功铁道市场3.安帕瓦水上市场买买买，吃吃吃，比西塘好 1.231.机场寄存行李2.机场大巴6号门a1去BTS3.BTS去siam 泰国印象1.垃圾桶少，但是路上垃圾不是很多2.斑马线、红绿灯不多，这里夸下泰国司机，路人示意要过马路，司机会主动让行人3.车速慢中午：百香果、芒果冰沙45Bthe chef 800B，鱿鱼丝4.夜场坑5.国内机可能早飞6.机场可寄存东西75B一件7.6号门A1 买东西：雪肌精乳液欧莱雅口红 唇釉V103鼻通肩痛祛疤烟","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"travel","slug":"travel","permalink":"http://yoursite.com/tags/travel/"},{"name":"thailand","slug":"thailand","permalink":"http://yoursite.com/tags/thailand/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"泰国游记序言","date":"2017-02-04T15:44:55.000Z","path":"2017/02/04/thailand00/","text":"这是一次真正意义上的说走就走的旅行，当我看到我同门师弟（其实也不算师弟，我们同届，只是他晚来几天^-^）在买飞机票的时候我就好奇的问了句“去哪里玩吗？”同时回了句“我也去可以？”。就这样的两个问句开始我2017年的第一次旅游，同时也是我的第一次出国游，同时也完成了我许许多多的第一次。最最重要的使这是我第一次写游记，本来没这种兴趣的，但是不知道怎么就在手机上写了一些简单的记录，回来了也就想着干脆写游记吧。毕竟这一路上自己也遇到了一些坑，就当给别人一些参考也好，而且一边写着一边回忆起旅游的乐事，真的很有意思，有的时候都会笑出来声来。 首先简单介绍一下一起出行的6个人。 从前往后介绍：一排左一是我们的财政大臣，所有公费都放在这个boy手上，办事沉稳一排右一是我们的欢乐使者，气氛莫名尴尬的时候只需要他发声立马暖场二排左一和右一是太阳伞CP，只要有太阳自动组合三排左一和右一是绯闻CP，学校到泰国到学校都是绯闻CP那么问题来了，那个才是真的我 再简单介绍一下我们的行程：旅游方式：自助游+两个一日团行程：为期8天，旅游城市：清迈，普吉和曼谷住宿：名宿和酒店出行方式：飞机，出租，包车，船和嘟嘟车（凸凸车）电话：happy卡花费：旅游+购物 7000+RMB","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"travel","slug":"travel","permalink":"http://yoursite.com/tags/travel/"},{"name":"thailand","slug":"thailand","permalink":"http://yoursite.com/tags/thailand/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"小章鱼2017年计划","date":"2017-01-14T15:53:55.000Z","path":"2017/01/14/2017plan/","text":"前言 2016年已经过去了。 2017年计划非技术文艺片 至少观看两部话剧(周五晚上)，话剧表演艺术以及观众对的素质，是我深深的爱上了话剧这种艺术形式 至少观看六部电影 至少看十本课外书，生活不止眼前的苟且，还有诗和远方的田野。 去上海野生动物园(携程买)，喜欢看BBC对于动物纪录片的记录。 找有意思的地方，逛逛街，拍照(周末)，陪她走过尘世的美好。 给对方写信(要真诚)，把真情融入文字中。 励志片(祝福她考研成功) 每天背单词(互相打卡)加油！ 坚定她考研信念，不放弃，给她鼓励。 最终目标 帮助她考上研究生，然后一起去台湾或者云南玩耍。","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"paln","slug":"paln","permalink":"http://yoursite.com/tags/paln/"}]},{"title":"hexo 安装第一篇","date":"2017-01-12T15:23:41.000Z","path":"2017/01/12/creathexo/","text":"第一步安装 nodenode 第二步安装 gitgit 第三部安装 hexo$ npm install -g hexo-cli 第四步创建hexo文件夹‘hexo init’这里有一个坑的地方在于使用的使npm安装的初始theme的时候很慢，你耐心等待就好了 第五步安装hexo依赖npm install 第六步创建hexo文件夹所在目录执行hexo ghexo s可以在localhost：4000访问到页面这里有一个坑的地方是如果以上步骤都对的话，如果访问4000端口没有页面，那就你就是安装了福新阅读器，不要问我问什么知道执行hexo s -p 5000 本地的介绍到这里 参考链接hexo官网博客","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Markdown 学习笔记","date":"2017-01-12T07:14:01.000Z","path":"2017/01/12/start/","text":"段落第一段第二段第三段源代码 # 第一段 ## 第二段 ### 第三段 列表 苹果 香蕉 菠萝源代码123* 苹果* 香蕉* 菠萝 引用、斜体、加粗 天空没有鸟的痕迹，但我已飞过。 –泰戈尔源代码&gt; _天空没有**鸟**的痕迹，但我已飞过_。 --泰戈尔 代码块1234567891011121314ul &#123; margin: 0 0; padding: 0 0; list-style-type: none;&#125;li &#123; float: right; width: 80px; height: 40px; margin-right: 5%; margin-bottom: 10px; line-height: 40px; text-align: center;&#125; 源代码(css ul { margin: 0 0; padding: 0 0; list-style-type: none; } li { float: right; width: 80px; height: 40px; margin-right: 5%; margin-bottom: 10px; line-height: 40px; text-align: center; }) 分割线 源代码 - - - 链接i am 404i am baidu源代码 [i am 404](https://twitter.com/Tracy_xzh) [i am baidu](https://www.baidu.com) 参考链接链接","tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"},{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]}]