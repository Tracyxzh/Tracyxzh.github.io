[{"title":"sshr","date":"2018-04-05T02:04:02.000Z","path":"2018/04/05/sshr/","text":"前言科学上网的是从研一开始的，开始都是使用蓝灯和green这两个免费的VPN。想过去买VPN，有人推荐过熊猫翻滚（听名字还蛮可爱的）。想到以后工作科学上网的需求更多，就决定自己搭个梯子，最后经人推荐选择了vultr。 搭建步骤第一步登陆vultr官网，注册登陆 第二步购买服务器，点击下图中的加号 第三步ping一下服务器，可能是一个脏ip。如果ping通了就进行下一步，ping不通就22334再来一次，删除刚刚买的服务器，再买一个。（ps：购买前需要给账户充值，这个还支持了alipay）安装好后 第四步登陆服务器 可以本地ssh到服务器 可以点击网页的view console登陆服务器 第五步修改root密码 第六步ssr一件脚本安装脚本地址中间的过程中全部选择默认就好，最后记住自己设置的端口、协议、混淆、ip、passwd，这些信息都将在登陆工具中填写 第七步安装登陆工具mac：工具下载，分支下载windows：教程安装百度云盘链接：https://pan.baidu.com/s/1jyTXsAp9gPwepfV7gLWZzA ios：要折腾一会的。步骤： 注册一个美区账号，用笔记本翻墙状态登陆苹果官网注册 购买vpn（winpy下架了，付费的需要信用卡）android: 应用商店搜索SSR 网络提速bbr一键脚本安装脚本地址","tags":[{"name":"科学上网","slug":"科学上网","permalink":"http://yoursite.com/tags/科学上网/"}]},{"title":"RoiPooling","date":"2018-03-31T07:06:36.000Z","path":"2018/03/31/RoiPooling/","text":"RoiPoolingRoiPooling是用在Faster RCNN由RBG大神提出的一种方法。主要原因可以从RCNN和Fast RCNN等提起，这里长话短说。定义好网络结构以后网络的输入和输出是固定的，那么对于不同的输入，输出必然是不同的。传统的解决方法是通过resize输入图像的大小，这样的话对于原始输入显然有影响。为了解决这个问题还一个思路就是在网络中添加一个类似动态的结构，这里RBG大神使用的就是RoiPooling，通过此用这种特殊的池化结构，使得不同的输入可以输出相同的输出。参考链接一解释为：它的目的是对不规范的输入进行max pooling，以获得固定尺寸的feature maps（例如7×7）。 具体步骤RoiPooling最终输出相同大小的feature map，具体步骤是：1.把region proposal划分成等大小的部分（其数目等同于输出的维度）。2.对每个部分取最大值 参考链接英文翻译","tags":[{"name":"目标检测","slug":"目标检测","permalink":"http://yoursite.com/tags/目标检测/"},{"name":"RoiPooling","slug":"RoiPooling","permalink":"http://yoursite.com/tags/RoiPooling/"}]},{"title":"视频模型","date":"2018-03-25T15:21:29.000Z","path":"2018/03/25/videomodel/","text":"常用图像模型 HSV颜色模型 色调（Hue），饱和度（Saturation），明暗度（Value） 肤色模型 形状模型 人体可变模型 高斯混合模型 概率图模型 感兴趣区域模型 视觉显著性模型 多分辨率模型 视频池袋模型 视频语义模型 参考书籍和链接《视觉大数据基础与应用》","tags":[{"name":"图像处理","slug":"图像处理","permalink":"http://yoursite.com/tags/图像处理/"},{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/tags/人工智能/"}]},{"title":"looking at outfit to parse clothing","date":"2017-10-08T00:58:09.000Z","path":"2017/10/08/fashionPaper3/","text":"Abstract本文基于全卷积神经网络（FCN）对于服装进行语义分割。服装语义分割的研究有助于服装检索。本文扩展了FCN网络结构，添加了一个分支网络，该网络使用服装编码来预测一组服装的标签，从而鼓励组合便好。本文还使用条件随机场（CRF）明确地考虑给定图像的相干标记分配。 Introduction本文的贡献1）添加一个分支网络2）web-based 工具用于标注3）服装编码有助于服装检索 Related Work1）语义分割2）服装解析3）服装检索 学校表现，需要结合个人简历，从在校成绩、是否保研、是否党员、在校奖励等可以表现出亮点的方面描述； Our approach fine-tuning VGG16分支网络类似一个过滤器，过滤那些错误预测的像素，这个是从像素的角度分析。最后的CRF座位post-processing step更精确的分割，这个是从区域的角度分析。 参考链接论文地址gating fucntionCRF","tags":[{"name":"paper","slug":"paper","permalink":"http://yoursite.com/tags/paper/"},{"name":"fasion","slug":"fasion","permalink":"http://yoursite.com/tags/fasion/"}]},{"title":"Who Leads the Clothing Fashion:Style, Color, or Texture?","date":"2017-10-05T13:24:17.000Z","path":"2017/10/05/fashionPaper1/","text":"Abstract本文基于分类模型分析Style, Color, Texture对于流行的影响。结论：Style影响最大，其次是Color，最后是Texture。 Introduction前几段介绍了Style, Color, Texture这三个因素对于流行的影响。将Style, Color, Texture这三个因素作为机器学习中的特征用于分类。最后的评估标准是：分类acc越高，影响越大。 Methods数据集：STYLE130, Color335,Outex-TC-00021,FASHION8预处理：归一化尺寸，grab cut去除背景特征提取方法：shape feature：SIFTcolor feature：Color Nametexture feature：LBP分类方法：SVMlabel：one-vs-all12345678910111213141516171819202122SIFT code#!/usr/bin/env python# encoding=utf-8# -------------------------------------------------------------------------------# Name: SIFT# Author: xiezhanghua (xiezhanghua111@j163.com)# Created: 2017/10/6上午7:35# -------------------------------------------------------------------------------import cv2import matplotlib.pyplot as pltimg = cv2.imread(&apos;1.jpg&apos;)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)# surf = cv2.xfeatures2d.SURF_create()surf = cv2.xfeatures2d.SIFT_create()kp = surf.detect(gray, None)img = cv2.drawKeypoints(gray, kp, img)plt.imshow(img)plt.show() 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# encoding=utf-8# -------------------------------------------------------------------------------# Name: LBP# Author: xiezhanghua (xiezhanghua111@j163.com)# Created: 2017/10/6上午7:35# -------------------------------------------------------------------------------from skimage.feature import local_binary_patternimport matplotlib.pyplot as pltimport cv2# settings for LBPradius = 3n_points = 8 * radius# 读取图像image = cv2.imread(&apos;1.jpg&apos;)#显示到plt中，需要从BGR转化到RGB，若是cv2.imshow(win_name, image)，则不需要转化image1 = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)plt.subplot(131)plt.imshow(image1)# 转换为灰度图显示image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)plt.subplot(132)plt.imshow(image, cmap=&apos;gray&apos;)# 处理lbp = local_binary_pattern(image, n_points, radius)plt.subplot(133)plt.imshow(lbp, cmap=&apos;gray&apos;)plt.show() 参考链接论文地址数据集sift demo","tags":[{"name":"paper","slug":"paper","permalink":"http://yoursite.com/tags/paper/"},{"name":"fasion","slug":"fasion","permalink":"http://yoursite.com/tags/fasion/"}]},{"title":"PIL rgb2hsv rgb2hls rgb2yuv","date":"2017-07-07T03:55:06.000Z","path":"2017/07/07/PIL/","text":"前言最近在参加一个招商图像的比赛，就准备用python做，这里记录下中间遇到的一些坑。软件安装配置的坑就不写了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364def rgb2hsv(img): if isinstance(img, Image.Image): r, g, b = img.split() Hdat = [] Sdat = [] Vdat = [] for rd, gn, bl in zip(r.getdata(), g.getdata(), b.getdata()): h, s, v = colorsys.rgb_to_hsv(rd / 255., gn / 255., bl / 255.) # h, s, v = colorsys.rgb_to_yiq(rd / 255., gn / 255., bl / 255.) # h, s, v = colorsys.rgb_to_hls(rd / 255., gn / 255., bl / 255.) Hdat.append(int(h * 255.)) Sdat.append(int(s * 255.)) Vdat.append(int(v * 255.)) r.putdata(Hdat) g.putdata(Sdat) b.putdata(Vdat) # return Image.merge(&apos;RGB&apos;, (r, g, b)) return r, g, b else: return Nonedef rgb2hls(img): if isinstance(img, Image.Image): r, g, b = img.split() Hdat = [] Sdat = [] Vdat = [] for rd, gn, bl in zip(r.getdata(), g.getdata(), b.getdata()): h, l, s = colorsys.rgb_to_hls(rd / 255., gn / 255., bl / 255.) # h, s, v = colorsys.rgb_to_yiq(rd / 255., gn / 255., bl / 255.) # h, s, v = colorsys.rgb_to_hls(rd / 255., gn / 255., bl / 255.) Hdat.append(int(h * 255.)) Sdat.append(int(l * 255.)) Vdat.append(int(s * 255.)) r.putdata(Hdat) g.putdata(Sdat) b.putdata(Vdat) # return Image.merge(&apos;RGB&apos;, (r, g, b)) return r, g, b else: return Nonedef rgb2yuv(img): if isinstance(img, Image.Image): r, g, b = img.split() Ydat = [] Udat = [] Vdat = [] for rd, gn, bl in zip(r.getdata(), g.getdata(), b.getdata()): y = 0.3 * rd + 0.59 * gn + 0.11 * bl u = -0.15 * rd + -0.29 * gn + 0.44 * bl v = 0.51 * rd + 0.52 * gn + -0.095 * bl Ydat.append(int(y)) Udat.append(int(u)) Vdat.append(int(v)) r.putdata(Ydat) g.putdata(Udat) b.putdata(Vdat) return r, g, b else: return None","tags":[{"name":"pillow","slug":"pillow","permalink":"http://yoursite.com/tags/pillow/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"图像处理","slug":"图像处理","permalink":"http://yoursite.com/tags/图像处理/"}]},{"title":"逻辑回归","date":"2017-06-28T02:07:50.000Z","path":"2017/06/28/logicalRegression/","text":"前言最近在做一个早期预警的模型，这个模型用到了逻辑回归，这里记录下自己学习逻辑回归的笔记。 sigmod函数推导逻辑回归用到sigmod函数作为概率模型，相信很多人在一开始看机器学习相关书籍的时候就看到了，但是为什么可以用sigmod函数作为概率模型还有很多疑惑。这里首先讲解下为什么可以用sigmod函数作为概率模型。其实机器学习的核心也就是要找到一个概率模型和找到损失函数，然后使得损失函数最小不断地改进系数。下图是sigmod的推导，手写字有点难看😂 决策函数一个机器学习的模型，实际上把决策函数限定在某一组条件下(也就是特征)，这组限定条件决定了模型的假设空间。 损失函数 参考链接美团技术博客知乎edusoftmax","tags":[{"name":"logical","slug":"logical","permalink":"http://yoursite.com/tags/logical/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"R工具包-RMySQL和数据处理和加工相关包","date":"2017-06-26T03:12:41.000Z","path":"2017/06/26/RpackgeRmysql/","text":"前言R要处理的数据保存在数据库中，应考虑R与MySQL之间的数据输入和输出问题，RMySQL包正是为了解决这些问题而推出的。 RMySQL安装12install.packages(&quot;RMySQL&quot;)library(RMySQL) MySQL函数123456789RMySQL::dbConnect : 连接数据库RMySQL::dbConnect( drv, user, password, dbname, host)返回连接对象 12345RMySQL::dbListTables : 获取数据库中的数据表列表RMySQL::dbListTables( conn # 数据库连接)返回数据库中的列表 12345RMySQL::dbGetQuery : 想数据库运行给定查询RMySQL::dbGetQuery( conn, statment) 数据处理和加工相关包12345678包 | 用途sqldf | 使用SQL处理数据plyr | 拆分数据，对拆分的数据应用apply函数，合并结果reshape2 | 数据整理与汇总data.table | 代替R数据框更快的数据类型foreach | 用途doParaller | 用途 testthat | 用途 参考资料github","tags":[{"name":"R","slug":"R","permalink":"http://yoursite.com/tags/R/"},{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}]},{"title":"R数据操作","date":"2017-06-25T13:54:59.000Z","path":"2017/06/25/Rdata/","text":"前言R主要是基于向量处理数据，与使用for循环逐个处理单个数据的方式相比，基于向量的处理速度更快。 R中常用数据集123456789数据集 | 含义AirPassenger | Box &amp; Jenkins航空公司1949～1960年每月国际航线乘客数 airquality | 纽约市1973年5月～9月每日空气质量cars | 20世纪20年代汽车速度对刹车距离的影响mtcars | 1974年美国Motor Trend杂志上刊登的的32辆车的11个指标数据Titanic | “泰坦尼克”号生还者信息，包含舱室（一等舱、二等舱、三等舱）、性别、年龄、是否生还InsectSprays | 使用6中杀虫剂后各自的害虫存活率Orange | 橙数的种类、树龄、树围swiss | 1888年前后，瑞士联邦47个法语州的生育率鱼社会经济指标 apply系列函数123456函数 | 说明apply() | 向数组或矩阵应用指定函数，然后将结果以向量、数组或列表形式返回 lapply() | 向向量、列表或表达式应用函数，并以列表形式返回sapply() | 与lapply()类似，但以向量、矩阵或数组形式返回tapply() | 根据指定标准对向量中的数据分组，然后对每个分组应用指定函数，并返回结果mapply() | sapply()扩展版本，借助参数接收多个向量或列表，然后对各个数据的第一个元素应用函数计算结果，然后针对第二个。。。类推，然后返回计算结果 apply()12345678说明：沿着MARGIN方向，向数组或矩阵应用函数FUN，并以向量、数组或列表形式返回结果apply( x, # 数组或矩阵 MARGIN， # 应用函数方向，1是沿着行方向，2是沿着列方向 c(1,2)表示同时沿着行和列方向 FUN # 应用函数 )FUN函数返回长度为1的向量时，返回向量；返回大于1的向量时，返回矩阵；返回长度不同向量时，返回列表 lapply()1234567说明：向列表、向量、表达式、数据框等应用指定函数，并将结果以列表形式返回lapply( x, # 向向量、列表或表达式 FUN, # 应用函数 ... # 额外参数，会传给FUN)返回于x等长的列表 sapply()1234567说明：与lapply()类似，但以向量、矩阵形式返回sapply( x, # 向向量、列表或表达式 FUN, # 应用函数 ... # 额外参数，会传给FUN)FUN函数返回长度为1的向量时，返回向量；返回大于1的向量时，返回矩阵 tapply()1234567说明：根据指定标准对向量中的数据分组，然后对每个分组应用指定函数，并返回结果tapply( x, # 向量 INDEX, # 数据分组索引，该参数应该设置为因子，非因子的数据类型会被自动转换为因子 FUN, # 要向分组应用的函数 ... # 额外参数，这些参数被传递给FUN函数) mapply()12345说明：将以列表或向量形式给出的参数传递给指定函数，并返回函数执行结果mapply( FUN, # 等待执行的函数 ... # 等待传递的参数) 随机数生成函数12345函数 | 含义 rnorm(n, mean = 0, sd = 1) | 生成n个均值为mean、标准差为sd的正态分布的随机数runinf(n, min = 0, max = 1) | 生成n个均匀分布的随机数，最小值为min，最大值为maxrpois(n, lambda) | 生成n个lamada为lambada的泊松分布随机数rexp(n, rate = 1) | 生成n个lambda为rate的指数分布随机数 数据拆分于合并函数1234函数 | 特征split() | 根据给定条件拆分数据subset() | 选择满足给定条件的数据merge() | 基于共同值的合并数据 split()123456说明：根据给定条件拆分数据split( x, # 拆分数据 f # 保存拆分的因子)返回保存拆分数据的列表 subset()1234567891011说明：选择满足给定条件的数据subset( x, # 等待选取局部数据 subset # 是否要选取数据)subset( x, # 等待选取局部数据 subset, # 是否要选取数据 select # 数据框时，要选取的列) merge1234567891011121314说明：根据共同的列名或行名合并数据merge( x, # 等待合并的数据框 y # 等待合并的数据框)merge( x, # 等待合并的数据框 y, # 等待合并的数据框 by, # 用于合并基准的列，x,y列名不同时， all = FALSE, all.x, all.y) 访问数据框中的列123456访问数据框中的列，若每次都要使用df$colname的形式，则意味着每次都要反复使用数据框名称df和$符号，这回造成代码冗余。函数 | 特征with() | 允许在代码块内部只使用属性名直接访问数据within() | 功能于with()一样，但可以轻松修改数据值 attach() | attach()之后的代码中，可以只使用属性名直接访问数据detach() | 作用和attach()相反，detach()之后的代码中，无法继续使用属性名直接访问数据 参考资料《R语言与数据分析》","tags":[{"name":"R","slug":"R","permalink":"http://yoursite.com/tags/R/"},{"name":"数据操作","slug":"数据操作","permalink":"http://yoursite.com/tags/数据操作/"}]},{"title":"R工具包-pryr","date":"2017-06-23T01:52:49.000Z","path":"2017/06/23/Rpackgepryr/","text":"前言今天学习R学习到了面向对象编程，以为自己对于面向对象应该是很了解了，但是发现里面有对歌面向对象系统，S3，S4，参考类，基础类型。不多说其他的，开始学习下pryr的使用，然后掌握这4个面向对象系统。 介绍pryr是一个深入了解R底层的一个包 API 方便理解内部实现的API: promises对象： 环境和作用域： 闭包： 函数调用关系： 基础类型： 复制和修改： 观察和理解R面向对象系统的API: 判断对象属于哪个面向对象系统：otype() 判断方法属于哪个面向对象系统：ftype() 辅助编程的API* 改变创建函数：make_function(), f() 表达式替换：substitute_q(), subs() 修改：modify_lang() 匿名函数：partial() 函数匹配：find_funs() 代码简化工具： 创建延迟或直接绑定：%&lt;d-%, %&lt;a-% 创建常量：%&lt;c-% 重新绑定：rebind, &lt;&lt;- 安装12install.packages(&quot;pryr&quot;)library(pryr) 参考链接github博客","tags":[{"name":"R","slug":"R","permalink":"http://yoursite.com/tags/R/"},{"name":"pryr","slug":"pryr","permalink":"http://yoursite.com/tags/pryr/"}]},{"title":"R工具包-lubridate","date":"2017-06-22T05:51:02.000Z","path":"2017/06/22/Rpackgelubridate/","text":"前言R语言用到了对于时间的处理 安装12install.packages(&quot;lubridate&quot;)library(&quot;lubridate&quot;) APIymd(), ymd_hms, dmy(), dmy_hms, mdy()这一类是用来简化string转date，这里再简单介绍下as_date，y代表2为年(16)，Y代表4位年(16)，m代表月份(12)，d表示日期(3)，b表示月份英文简写，B表示月份英文全称 year(), month(), mday(), hour(), minute() and second()通过以上api获取日期的年月日时分秒 with_tz(), force_tz()显示和改变时区 参考链接lubridateDates and Times in R","tags":[{"name":"R","slug":"R","permalink":"http://yoursite.com/tags/R/"},{"name":"lubridate","slug":"lubridate","permalink":"http://yoursite.com/tags/lubridate/"}]},{"title":"R数据可视化-ggplot2","date":"2017-06-22T01:46:03.000Z","path":"2017/06/22/RDataVisualization/","text":"前言数据可视化是最直观的展示数据的一种方式。R语言提供了多种绘图系统，借助它们可以轻松绘制散点图(scatter plot)、折线图(graph of broken line)、条形图(bar graph)、箱线图(box plot)等。R的绘图功能主要由graphics、lattice、ggplot这3个包提供 plot12345678910111213plot( x, # x y, # y xlab, # 横坐标name ylab, # 纵坐标name main, # 图name pch, # 点类型 cex, # 点大小 col, # 点颜色 xlim, # x范围 ylim, # y范围 type # 图像类型，p点，l线，b点线) par1234使用plot绘图，每次都会新建一个窗口，可以使用parpar( ... # 采用tag = value 方式设置参数) jitter12345jitter( x, # 数据 factor = 1, # 设置噪声水平 amount = null) points、lines、abline在plot的图纸上添加点和线、直线 安装install.packages(“tidyverse”)library(tidyverse) 绘图函数ggplot(data = ) + (mapping = aes()) 例子12345678910111213141516171819202122ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, size = class))说明:mpg是这个包中自带的一份数据，这个数据是美国环境保护局对于38种车型的统计数据mpg#&gt; # A tibble: 234 × 11#&gt; manufacturer model displ year cyl trans drv cty hwy fl#&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;#&gt; 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p#&gt; 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p#&gt; 3 audi a4 2.0 2008 4 manual(m6) f 20 31 p#&gt; 4 audi a4 2.0 2008 4 auto(av) f 21 30 p#&gt; 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p#&gt; 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p#&gt; # ... with 228 more rows, and 1 more variables: class &lt;chr&gt;aes(x = displ, y = hwy)：这里是绘制displ和hwy关系的二维图像size = class:对于图像中的点根据class分类使用不同的大小，这里还可以使用color，shape，alpha，这几个单词的字面意思，大家可以动手实现一下 切分图像1234ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class)facet_wrap 第一个参数是切分依据的字段，该字段需要是离散的 线性1234ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy))说明：geom_smoothgenjudispl和hwy线性拟合，如果加上入入geom_point后一样的分类现实例如：color=drv,将根据drv分类拟合并且显示不同的颜色 统计1234567891011121314151617181920diamonds# A tibble: 53,940 x 10 carat cut color clarity depth table price x y z &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 4 0.29 Premium I VS2 62.4 58 334 4.20 4.23 2.63 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.4910 0.23 Very Good H VS1 59.4 61 338 4.00 4.05 2.39# ... with 53,930 more rowsggplot(data = diamonds) + geom_bar(mapping = aes(x = cut))说明：直方图，横坐标是cut，纵坐标默认是count，可以改变图像的颜色，fill属性改变填充色，color属性改变外围色，alpha改变透明度 参考链接Data visualisationPDF","tags":[{"name":"R","slug":"R","permalink":"http://yoursite.com/tags/R/"},{"name":"数据可视化","slug":"数据可视化","permalink":"http://yoursite.com/tags/数据可视化/"}]},{"title":"R工具包-dplyr","date":"2017-06-21T15:12:32.000Z","path":"2017/06/21/Rpackgedply/","text":"前言项目中用到了几个R语言的包，顺道仔细学习下 函数name Descriptionselect() 选择列 # select(data, [-,start_with(), ends_with(),contains(),matches(),one_of()]olumn name, …)filter() 行过滤 # filter(data, column name[&gt;, &lt;, &gt;=, &lt;=, !=, %in%] condition)arrange() 整理行 # arrange(order, sleep_total) 排序mutate() 新建列 # mutate(rem_proportion = sleep_rem / sleep_total)summarise() 统计 # summarise(avg_sleep = mean(sleep_total))group_by() 分组 # group_by(order) 管道函数 %&gt;%功能类似于Linux的管道|一样 参考链接plyr_tutorial","tags":[{"name":"R","slug":"R","permalink":"http://yoursite.com/tags/R/"},{"name":"dplyr","slug":"dplyr","permalink":"http://yoursite.com/tags/dplyr/"}]},{"title":"R常用函数和数据结构","date":"2017-06-21T03:14:05.000Z","path":"2017/06/21/Rfunction/","text":"前言开始了R语言的学习 基础函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 首先要学习的函数? # 和help函数一样str # struture的简写# 重要的运算符和赋值函数%in%, match # a%in%y 判断a是否为y中的元素=, &lt;-, &lt;&lt;- # x=c(1,2,3) x&lt;&lt;-x*2 结果 x=c(2,4,6)更新x的值$, [, [[, head, tail, subset # head(1:50, 10) [1]1 2 3 4 5 6 7 8 9 10 tail(1:50, 10) [1] 41 42 43 44 45 46 47 48 49 50withassign, get# 比较all.equal, identical # identical(a,b) 判断对象是否相同 !=, ==, &gt;, &gt;=, &lt;, &lt;=is.na, complete.casesis.finite# 基础数学*, +, -, /, ^, %%, %/% # %% 取余 # %/% 取整abs, sign # sign 指示函数acos, asin, atan, atan2sin, cos, tanceiling, floor, round, trunc, signif # trunc 去除小数 signif(data, n) data 精确的位数为n，包括整数exp, log, log10, log2, sqrtmax, min, prod, sum # prod 连乘cummax, cummin, cumprod, cumsum, diff # cu开头的函数计算累计值 # diff计算间隔pmax, pmin # pmax(x,y,z) 返回x,y,z各列的最大值range # 取出最大最小值mean, median, cor, sd, var # cor 相关系数 sd 均方差Standard Deviation var 方差rle # Run Length Encoding 连续变量统计# 处理函数的函数functionmissingon.exitreturn, invisible# 逻辑与集合&amp;, |, !, xor # &amp;, | 用于对保存逻辑值的向量进行运算运算，并按元素逐个进行&amp;&amp;, || # &amp;&amp;, || &amp;&amp;并不用于在向量的元素之间的运算，它用于运算两个逻辑值all, anyintersect, union, setdiff, setequal # union 求合集 intersect 求交集 setdiff 求差集 setequal 判断x和y是否相同which # 用法which(test)。返回test为真值的位置 # 向量与矩阵c, matrix# 强制转换规则字符型(character)&gt;数值型(numeric)逻辑型(logical)length, dim, ncol, nrowcbind, rbind # rbind(x,y) # 按行合并指定数据names, colnames, rownames # names 定义或返回向量c的元素名字t # 求转置diagsweepas.matrix, data.matrix# 构建向量crep, rep_len # 保存重复向量值的向量 rep(x,times,each) x:保存重复的向量 times:整个向量重复的次数 each:每个元素重复的次数seq, seq_len, seq_along # 连续数字组成的向量 seq 创建序列，seq(from, to, by) by是步长默认是1 seq_along(along.with) 根据along.with的长度n创建序列 seq_len(n) 根据n创建长度为n的序列revsamplechoose, factorial, combn(is/as).(character/numeric/logical/...)# 列表和数据框list, unlist # unlist 将列表转换为向量 unlist(x,recursive=FALSE,use.names=TRUE)data.frame, as.data.framesplit # 根据给定条件拆分数据 split(x,f) x:要拆分的向量或数据框 f:保存拆分基准的因子expand.grid# 控制流if, &amp;&amp;, || (short circuiting)for, whilenext, breakswitchifelse # ifelse(test, yes, no) test为真，输出yes值，否则输出no值。# apply函数和相似函数lapply, sapply, vapply apply # 向数据或矩阵应用指定函数，然后奖结果值以向量、数组或列表的方式返回tapplyreplicate # replicate(n, f) # 对于函数f运行n次 常见数据结构123456789101112131415161718192021222324252627282930# 日期时间ISOdate, ISOdatetime, strftime, strptime, date difftime # difftime(date1, date2) 返回时间差julian, months, quarters, weekdays # weekdays(date) 返回星期几 # quarters() 返回季度 # moths() 返回月份 # julian(date) 返回date离19700101的天数library(lubridate)# 字符处理grep, agrepgsub # 字符替换 gsub(pattern, replacement, x)strsplitchartrnchartolower, touppersubstrpaste # paste(data1, data2, sep = &quot;world&quot;) 结果是data1和data2拼接中间以world连接，world是可以自己定义的library(string)# 因子factor, levels, nlevelsreorder, relevelcut, findIntervalinteractionoptions(stringAsFactors = FALSE)# 数组处理arraydimdimnamesapermlibrary(abind) 统计函数12345678910111213141516171819202122232425262728# 排序和制表duplicated, unique # unique 找出不同的元素mergeorder, rank, quantilesorttable, ftable# 线性模型fitted, predict, resid, restandardlm, glmhat, influence.measureslogLik, df, devianceformula, ~, Ianova, coef, confint, vcovcontrasts# 测试类函数apropos(&quot;\\\\.test$&quot;)# 随机变量(q, p, d, r) * (beta, binom, cauchy, chisq, exp, f, gamma, geom, hyper, lnorm, logis, multinom, nbinom, norm, pois, signrank, t, unif, weibull, wilcox, birthday, tukey)# 矩阵运算crossprod, tcrossprodeigen, qr, svd%*%, %o%, outer # a%*%b 求矩阵a和矩阵b的积rcondsolve # solve(a,b) a矩阵，b向量或矩阵 求a%*%x=b的x，若不指定，则求a的逆矩阵 使用R123456789101112131415161718192021222324# 工作空间ls, exists, rm # ls: 当前工作空间中的objects # exists 判断是否存在当前工作空间 # rm 删除工作空间中某个objectgetwd, setwd # 返回当前工作空间 # 设置当前工作空间q # 退出source # &quot;预装&quot;函数,向R脚本导入其他函数并运行install.packages, library, require # 帮助help, ?help.searchaproposRSiteSearchcitationdemoexamplevignette# 调试tracebackbrowserrecoveroptions(error = )stop, warning, messagetraCath, try I/O函数12345678910111213141516171819202122232425262728# 输出print, catmessage, warningdputformatsink, capture.output# 读／写数据datacount.fieldsread.csv, write.csvread.delim, write.delim read.fwf readLines, writeLinesreadRDS, saveRDSload, save library(foreign)# 文件和目录dirbasename, dirname, tools::file_extfile.pathpath.expand, normalizePathfile.choosefile.copy, file.create, file.remove, file.rename, dir.createfile.exists, file.infotempdir, tempfiledownload.file, library(downloader) 查看帮助1234567help 或 ? :调用帮助系统help.search 或 ??: 搜索包含指定字符串的文档example: 运行帮助页面中的Example部分help.start: 现实包含R系统帮助的html页面 NA处理函数na.fail(object, …) # 若object中包含NA，则失败na.omit(object, …) # 若object中包含NA，则排除na.exlude(object, …) # 若object中包含NA，则排除，这与na.omit一样。但使用naresid napredeitct的函数中，通过NA排除的行再次添加到结果na.pass(object, …) # 即使object含有NA值，也使之通过 参考文献require和library《R语言与数据分析》","tags":[{"name":"R","slug":"R","permalink":"http://yoursite.com/tags/R/"}]},{"title":"机器学习资料记录","date":"2017-06-16T15:34:39.000Z","path":"2017/06/16/mathinelearning/","text":"前言机器学习最近才开始上手去弄，但是自己是真的挺喜欢的，发现自己学习的很多东西都能派上用场，所以这里记录下一些好的学习资料，大家一起前进 现在在看的课程 湾湾老师讲的很通俗易懂国立台湾大学林轩田开的两门课：机器学习基石（适合入门），机器学习技法（适合提高） 最近在看的书《机器学习实战》《机器学习》周志华 这本书也叫做“西瓜书”《统计学方法》李航 最近看的文章一些库从神经元到CNN、RNN、GAN…神经网络看本文绝对够了 最近在看的paper 每日音乐推荐评论：A_Zalee：瞎扯，假设抖腿振动幅度为5cm，则振动一次是10cm=0.1m，频率是7.5×10^14Hz，平均速度是7.5×10^13m/s，为光速的250173倍，明显违反狭义相对论。◆◆沉著的大叔：其实抖腿没什么不好，不仅能缓解压力，而且当速度达到每秒750,000,000,000,000次(750THz)时，理论上将产生可见光电磁波，膝盖会闪闪发光。燃烧自己，照亮他人，大家一起试试看吧。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"transaction","date":"2017-06-08T02:10:54.000Z","path":"2017/06/08/transaction/","text":"前言前段时间在PL/SQL写了一条sql语句，出入了数据，但是数据库中没有数据。后来发现是因为自己对于事务了解不够 定义事务是一条有多条sql语句组成的工作逻辑单元，这些语句要么全部执行成功，要么全部不执行，只要有一条sql语句执行失败，则已执行的sql语句会回滚刀执行之前的状态。 oracle 事务与SQL Server的区别在SQL Server中，每一个DML语句都具有一个隐式的事务，语句执行结束时事务被自动提交到服务器端，除非显示的通过一条事务语句开始一个事务，在oracle中，当第一条SQL开始执行时，一个新的事务就开始了，除非显示的地使用COMMIT进行提交，或者使用ROLLBACK进行回滚，或者是退出某个oracle工具时，这些事务才结束，否则SQL语句的操作仅在会话级别进行，没有保存到数据库中。 COMMIT提交事务COMMIT语句会结束数据数据库事务，他做了如下几个方面的工作* 如果对数据库使用了DML语句进行了修改，那么这些修改就会永久写进数据库中，这时其他用户可以立即看到对事务的修改 加在事务上的所有锁及事务所占有的一切资源自动释放。 ROLLBACK回滚事务使用ROLLBACK的情形一般有： 误删除了数据或更改了错误的数据，使用回滚帮助恢复原始的数据 如果触发了一个异常或者sql语句执行失败不能执行事务，使用回滚将数据恢复到初始状态 SAVEPOINT保存点默认情况下，ROLLBACK会撤销整个事务，如果编写一个很大的PL/SQL块，使用了很多的DML语句，此时回滚操作的工作量是很大的。PL/SQL提供了语句级别的回滚，允许将一个大的事务分成很多语句级别的小块，每个小块作为一个保存点。 ROLLBACk TO SAVEPOINT 命令执行，将会发生如下几件事情： 从保存点以后所做的工作都被撤销，但是保存点未被释放，如果需要，可以再次撤销该保存点 自该保存点以后SQL语句就需要的锁和资源都被释放 虽然撤销到保存点，但是并不是结束整个事务，SQL语句处理挂起状态。","tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"},{"name":"事务","slug":"事务","permalink":"http://yoursite.com/tags/事务/"},{"name":"PL/SQL","slug":"PL-SQL","permalink":"http://yoursite.com/tags/PL-SQL/"}]},{"title":"协同过滤","date":"2017-06-06T13:50:11.000Z","path":"2017/06/06/collaborativeFiltering/","text":"前言最近在实习数据挖掘的工作，但是做的事情就是将oracle的存储过程改成spark sql，这里坦白下我的Scala还在学习的路上。但是我的学习习惯是刨根问底，数据挖掘最终用到的算法才是最终吸引我的。而且最近真的喜欢用网易云听歌，一边听着JBL中放着的歌，一边看着算法，想象自己喝着红酒🍷。所以今天看看推荐算法是如何实现的。 协同过滤 collaborative filtering之所以称为“协同”是因为该方法基于其他用户进行推荐。实际上，人们通过协同合作来形成推荐。其工作流程如下：假设要完成的任务是推荐一本书。那么会在网站上搜索与你兴趣类似的其他用户。一旦找到这个用户，就看看这个用户所喜欢的书然后将它们推荐给你。找到相似用户的方法一般是通过距离。距离一般化：明氏距离（Minkowski Distance）$$b(x,y)=(\\sum_{k=1}^{n} |x_{k}-y_{k}|)^{r^{1/r}}$$其中： r=1时，上述公式计算的就是曼哈顿距离 r=2时，上述公式计算的就是欧式距离 r=3时，上述公式计算的是上确界距离 缺点：r越到，某一维较大差异对最终差值的影响越大。 曼哈顿距离函数12345678910111213def manhattan(rating1, rating2): &quot;&quot;&quot;Computes the Manhattan distance. Both rating1 and rating2 are dictionaries of the form &#123;&apos;The Strokes&apos;: 3.0, &apos;Slightly Stoopid&apos;: 2.5&#125;&quot;&quot;&quot; distance = 0 commonRatings = False for key in rating1: if key in rating2: distance += abs(rating1[key] - rating2[key]) commonRatings = True if commonRatings: return distance else: return -1 #Indicates no ratings in common pearson 相关系数1234567891011121314151617181920212223242526def pearson(self, rating1, rating2): sum_xy = 0 sum_x = 0 sum_y = 0 sum_x2 = 0 sum_y2 = 0 n = 0 for key in rating1: if key in rating2: n += 1 x = rating1[key] y = rating2[key] sum_xy += x * y sum_x += x sum_y += y sum_x2 += pow(x, 2) sum_y2 += pow(y, 2) if n == 0: return 0 # now compute denominator denominator = (sqrt(sum_x2 - pow(sum_x, 2) / n) * sqrt(sum_y2 - pow(sum_y, 2) / n)) if denominator == 0: return 0 else: return (sum_xy - (sum_x * sum_y) / n) / denominator 余弦相似度1234def dot_product(v1, v2): return sum(a * b for a, b in zip(v1, v2))def similarity(v1, v2): return dot_product(v1, v2) / (magnitude(v1) * magnitude(v2) + .00000000001) 相似度选择： 如果数据受到分数贬值（即不同用户使用不同的评价范围）的时候，使用皮尔逊系数 如果数据稠密（几乎所有都没有零值）且属性值大小十分重要，那么可以使用欧氏距离或者曼哈顿距离 如果数据稀疏，考虑使用余弦相似度 参考书籍和链接《写给程序员的数据挖掘》书籍博客知乎 每文音乐推荐评论：草莓味的咸鱼：顾城有一首叫作《避免》的诗“你不愿意种花你说：‘我不愿看见它一点点凋落’是的为了避免结束你避免了一切开始”觉得和塞林格的《破碎故事之心》异曲同工之秒is a touch and yet not a touch想触碰却又收回手","tags":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"http://yoursite.com/tags/数据挖掘/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"数据仓库","date":"2017-06-04T13:52:54.000Z","path":"2017/06/04/dataWarehouse/","text":"前言最近在银联实习也算是做数据挖掘方面的工作，先前虽然有接触算法这一块，学校也开了机器学习这门课，但是对于数据仓库不是很了解。那个和厂商聊起来，他问我学过数据仓库吗，我没答应上来，所以今天准备好好学习下数据仓库。 定义20世纪80年代中期，“数据仓库”（Data Warahouse， DW）这个名词首次出现在号称“数据仓库之父”W.H.Inmon（恩门）的Building Data Warahouse一书中。恩门把数据仓库定义为“一个面向主题的，集成的，稳定的，随时间变化的数据的集合，以用于支持管理决策过程”。 主题面向主题组织的数据具有以下特点： 各个主题有完整，一致的内容以便在此基础上做分析处理 主题之间有重叠的内容，反映主题间的联系。重叠是逻辑上的，不是物理上的。 各主题的综合方式存在不同。 主题域应该具有独立性（数据是否属于该主题有明确的界限）和完备性（对该主题进行分析所涉及的内容均要在主题域内）。 集成性数据仓库中存储的数据一般从企业原有已建立的数据库系统中提取出来，但并不是所有数据的简单拷贝，而是经过抽取、筛选、清理、转换、综合等工作得到的数据。 稳定性数据仓库在某个时间段内来看是保持不变的。 随时间而变化数据仓库大多关注的是历史数据，其中数据是批量载入的，即定期操作型应用系统中接收新的数据内容，这使得数据仓库中的数据总是拥有时间维度。 数据仓库系统数据仓库组成数据仓库系统通常指一个数据库环境，而不是指一件产品。数据仓库系统的一般体系结构如下图所示，整个数据仓库系统分为源数据层、数据存储和管理层、OLAP服务器层和前端分析工具层 参考书籍和链接《数据仓库与数据挖掘概述》 每文音乐推荐评论：贾听听听不来课：Bob Dylan在给他在纽约的第一任女友Suze Rotolo的信中这样写道：这儿什么也没发生.狗在等着出门,贼在等着老妇人,孩子们在等着上学,条子们在等着揍人.每个人都在等着更凉快的天气.而我只是在等你.那些美好就在我们身边,但却没有被留意….","tags":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"http://yoursite.com/tags/数据挖掘/"},{"name":"数据仓库","slug":"数据仓库","permalink":"http://yoursite.com/tags/数据仓库/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"数据库约束","date":"2017-06-04T02:04:52.000Z","path":"2017/06/04/oraCons/","text":"前言在系统学习数据库之前，直接前面知识了解CURD操作的命令，有的时候再写代码的时候会遇到要求需要添加NOT NULL等约束，但是具体有哪些约束以及如何给出专业的解释，其实自己是比较虚的。所以今天准备系统学习下数据库的约束。 约束约束是数据库中不可少的一部分。约束的目的在于保持数据的完整性，数据完整性是指数据的精确性以及可靠性。约束的种类： 域完整性：对数据表中字段属性的约束，主要包括not null约束／唯一约束／检查约束 实体完整性：主键约束，关系中主属性不为null且不能有相同值。 参照完整性：外键约束，关系中外键必须是另一个关系的主键有效值 主键定义：主键被创建在一个或者多个列上，通过这些列的值或者值的组合，唯一地标识一条记录。特点： 定义了primary key 约束的列（或列组合）不能包含重复值，并且不能包含null值 Oracle自动为具有parimary key约束的列（或列组合）建立了一个唯一索引和not null约束 同一个表只能定义一个primary key约束 可以在列上定义primary key约束，也可以在多个列上组合上定义primary key约束 外键定义：外键约束可以保证使用外键约束的数据库列与所引用的主键约束的数据列一致，外键约束在一个数据表可以有多个。定义了foreign key约束的列称为外键列，被foreign key约束索引的列称为引用列。包含外键的表称为子表，包含引用列的表称为父表。特点： 定义了foreign key 约束的列中只能包含相应的其他表中引用的列的值，或为null 定义了foreign key 约束的列赫相应的引用列可以在同一个表中，这种情况称为自引用 同一个列可以同时定义foreign key和not null约束 foreign key必须参照一个primary key约束或者唯一约束约束 可以在列上定义foreign key约束，也可以在多个列上组合上定义foreign key约束 唯一约束（UNIQUE约束）定义：唯一性约束和主键约束很相似，不同的是主键约束在同一个表中只能有一个，而唯一约束在一个表中可以有多个 检查约束针对列值本身进行限制 参考书籍和链接《oracle 入门》 每文音乐推荐爱听音乐的猫大叔：爸妈只会简单地操作电脑，我在另一个城市上班，忙的发昏，很少回去。所以就在电脑上弄了个360，他们也不会杀毒，每次我回去，体检一下电脑，升一下级。昨天老妈打电话 ：儿子啊，360已经提示187天没有体检了………顿时，泪流满面。","tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"},{"name":"约束","slug":"约束","permalink":"http://yoursite.com/tags/约束/"}]},{"title":"oracle 内置函数","date":"2017-06-03T03:06:39.000Z","path":"2017/06/03/oracleFunction/","text":"前言由于有的时候需要对于字符串或则日期使用一些内置的函数，但是平时google的时候也比较麻烦，这里干脆做个记录，方便以后自己翻阅。 数值函数 ABS(n) 取绝对值 MOD(n2, n1) 取n2除以n1的余数 SIGN(n) 返回参数n的符号。1 0 -1 三角函数 COS(n) n为弧度 ACOS(n) SIN(n) TAN(n) 指数／对数函数 SQRT(n) n的平方根 POEWR(n2,n1) n2的n1次幂 EXP(n) e的n次幂 LOG(n1, n2) n1位底的n2对数 四舍五入函数 ROUND(n，integer) 四舍五入精确到小数点的integer位 TRUNC(n， integer) 截取到小数点的integer位 字符函数 参数都是字符类型的参数单引号LENGTH(char) 返回指定的字符长度 字符串截取参数(char,position[,substring_length])char：原始字符串position：要截取字符串的开始位置substring_length：截取的长度SUBSTR：以字符为单位SUBSTRB：以字节为单位SUBSTRC：以unicode为单位SUBSTR2：以UCS2代码点为单位SUBSTR4：以UCS4代码点为单位 字符串连接函数CONCAT(char1,char2)函数 效果与“||”相似 字符串搜索函数参数(string,substring[,position[,occurrence]])string：待搜索的字符串substring：要搜索的字符串position：搜索开始的位置,默认是1occuurrence：substring第几次出现，默认是1INSTR：以字符为单位INSTRB：以字节为单位INSTRC：以unicode为单位INSTR2：以UCS2代码点为单位INSTR4：以UCS4代码点为单位 字母大小转换函数UPPER(char)LOWER(char)INITCAP(char) 所有单词首字母大写 替换字符函数REPLACE(char,serch_string[,replace_string])char: 表示搜索的目标字符串search_string: 在目标中要搜索的字符串replace_string: 该参数可选，不填的话就是删除搜索的字符串 字符串的填充RPAD(expr1,n[,expr2])功能： 在字符串expr1的右边用字符串expr2填充，不填写expr2的话，就用空格填充LPAD(expr1,n[,expr2])功能： 在字符串expr1的左边用字符串expr2填充，不填写expr2的话，就用空格填充 删除字符串首尾指定字符的函数TRIM([LEADING|TRAILING|BOTH][trim_character FROM] trim_source)LEADING：删除trim_source的前缀字符TRAILING：删除trim_source的后缀字符trim_character：删除指定的字符，默认删除空格trim_source：被操作的字符串 日期函数系统时间SYSDATE SYSTIMESTAMP 数据库时区函数DBTIMEZONE 为日期加上指定月份函数ADD_MONTHS(data,integer)功能： 该函数返回指定的日期加上一个月份数后的日期 转换函数ASCIISTR(char) 将任意字符集的字符串转换为数据库字符集对应的ASCII字符串CAST(expr as type_name) 把expr参数转换成type_name类型 数值转换成字符串函数参数(n,[,fmt[,nlsparam]])n: 数值或者日期fmt：要转换的格式TO_CHAR(number)TO_CHAR(data) 字符串转日期函数TO_DATA(char[,fmt[,nlsparam]])char:待转换的字符fmt：表示转换的格式nlsparam：控制格式化时使用的语言类型 每文音乐推荐评论：无心廿曰：我懒到连喜欢的人，都懒的换菮煕：还是老妈说的话最经典，她说：“你们这代人呐，就是活的太明白了，所以什么都得不到。我们当年什么都糊里糊涂，该结婚结婚，该工作工作，现在什么都有。”","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}]},{"title":"视图 -- 数据库中的虚拟表","date":"2017-06-03T02:19:35.000Z","path":"2017/06/03/viewOracle/","text":"前言最近在银联实习，实习的内容是基于大数据平台的项目。目前的主要工作内容是数据准备，这需要接触到存储过程以及spark sql，存储过程中还有一些视图。对于存储过程了解程度由于前段时间学习过了，所以基本可以了，所以今天准备学习下视图这方面的知识。 定义视图：是一个基于一个或者多个表的逻辑表，视图本身不包括任何数据。 数据源 单一表的子集 多表操作的结果集 视图的子集 语法12345678910111213141516CREATE [ OR REPLACE ] [ [ ON ] FORCE ] VIEW[ schema. ] view[ (alias, ...) inline_constraint(s) ][ out_of_line_constrain(s) ]AS subquery[ WITH &#123; READ ONLY | CHECK OPTION [ CONSTRAINT constraint ] &#125;][说明]OR REPLACE:创建视图的时候如果存在同名视图则覆盖[ ON ] FORCE :表示是否强制创建，如果基表不存在的情况下创建视图会出现错误，强制创建可以先创建视图然后再创建基表。[ schema. ] view:视图所属方案或者视图的名称[ (alias, ...) inline_constraint(s) ]:视图字段的别名和内联约束[ out_of_line_constrain(s) ]:也是约束WITH READ ONLY:视图只读WITH CHECK OPTION [ CONSTRAINT constraint ]:一旦使用该约束，当视图增加或修改数据时必须满足子查询的条件。 参考书籍和链接《oracle 入门》 每文音乐推荐评论： 卖大白菜的：我有一老友，已经死掉了。她有双相情感障碍，对药物精神依赖，长期使用LSD，不健康，不自由，认为整个世界都在拒绝她，喜摇滚，爱抽烟，很酷，出众，也很脆弱，与3、4个14、5岁的少年相互戏弄被侮辱，溺亡在夏日黎明里的一块水塘。她的社交签名留着那句：他人即地狱。她肯定喜欢这首歌。 BeckyT-T：有些歌听着会觉得孤独真好，人生终究是自己的人生，任何人无法代替。","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}]},{"title":"给自己看的UML","date":"2017-04-06T13:25:46.000Z","path":"2017/04/06/uml/","text":"前言发现自己的心最近有点浮躁了，每次都是有那么一段时间很堕落。不将这个了，今天要讲的是关于设计模式的基础UML，你们可以去知乎上搜一搜，对于UML褒贬不一。我个人感觉还是有用的，如果图能够说明很多语言无法简单描述的问题，那么是不是减少了很多不必要的沟通误会呢。而且理解UML对于自己动手理清思路也很有帮助。 UML定义统一建模语言（英语：Unified Modeling Language，缩写 UML）是非专利的第三代建模和规约语言。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。 类图 123456781.类图前的+ - # 表示访问权限+ 表示public# 表示protect- 表示private2.类图有3层第一层是类名第二层是成员第三层是方法 UML关系符号 123456简单讲解下上图中5种类图关系。聚集关系：聚集指的是集合中的冬季是可以独立出来，比如飞机和飞机场的关系。组合关系：被包含者是包含者的一部分，比如汽车中的发动机继承关系：B派生自A，A泛化了B依赖关系：A依赖B，A使用B实例关系 这其中在图中还会出现一些特殊的数字比如1..1 0.. 1..1231..1: 表示另一个类的一个对象只与该类的一个对象有关0..*：表示另一个类的一个对象与该类零个或多个对象有关1..* 表示另一个类的一个对象只与该类零一个或多个一个对象有关 参考链接维基百科博客","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"uml","slug":"uml","permalink":"http://yoursite.com/tags/uml/"}]},{"title":"java 异常","date":"2017-03-22T08:06:42.000Z","path":"2017/03/22/exception/","text":"前言印象中对于，异常的了解就只是try，catch，然后用的比较多的几乎是Exception。以前学习的时候想的就是只要能用会用就好了，没怎么关注过异常，还以为Exception是所有异常的基类。昨天做了大众点评的实习笔试，发现自己理心仪的大众点评还是有一些差距的，笔试中关于异常的题目，自己都不是很了解。所以，今天就来探讨下java的异常和错误。 Throwable类Throwable类是java语言中所有错误和异常的基类，用来描述违例抛出的东西。Throwable有两种常规规范，Error和Exception。 Exception和ErrorError 代表编译期和系统错误，我们一般不必特意捕获它们（除在特殊情况以外）。Exception 是可以从任何标准 Java库的类方法中“掷”出的基本类型。此外，它们亦可从我们自己的方法以及运行期偶发事件中“掷”出。在Java中我们可以这样区分，异常(Exception)是一种非程序原因的操作失败(Failure)，而错误(Error)则意味着程序有缺陷(Bug)。 构造函数1234567891011121314151617181920Exception的构造函数，Error和和他一样。public Exception() &#123; super();&#125;public Exception(String message) &#123; super(message);&#125;public Exception(String message, Throwable cause) &#123; super(message, cause);&#125;public Exception(Throwable cause) &#123; super(cause);&#125;Trowable主要的方法 public void printStackTrace() &#123; printStackTrace(System.err);&#125;将此 throwable 及其追踪输出至标准错误流。此方法将此 Throwable 对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。输出的第一行包含此对象的 toString() 方法的结果。剩余行表示以前由方法 fillInStackTrace() 记录的数据。 RuntimeExceptionRuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。Java中区分Checked Exception和Unchecked Exception，前者继承于Exception，后者继承于RuntimeException。上面的IOException就是一个著名的Checked Exception。Java编译器对Checked Exception的约束包括两方面：对于方法编写者来讲，Checked Exception必须在方法签名上声明；对于方法调用者来讲，调用抛出Checked Exception的方法必须用try-catch捕获异常或者继续声明抛出。相反，Unchecked Exception则不需要显式声明，也不强制捕获。 Checked Exception的用意在于明确地提醒调用者去处理它，防止遗漏。但是Checked Exception同时也给调用者带来了负担，通常会导致层层的try-catch，降低代码的可读性，前面例子中的Integer.valueOf方法虽然声明了NumberFormatException，但是它是一个RuntimeException，所以使用者不是必须用try-catch去捕获它。 参考链接java 编程思想jdk博客","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"Exception","slug":"Exception","permalink":"http://yoursite.com/tags/Exception/"}]},{"title":"java四大引用：强、软、弱、虚","date":"2017-03-11T12:48:33.000Z","path":"2017/03/11/javacopy/","text":"前言紧张刺激的前言又来了，为什么会写这篇文档呢。因为我前两天阿里面试的时候问我了解引用吗，然后我说知道一点啊，回答的时候深拷贝和浅拷贝。但是呢具体的内层原理不知道，所以回答的时候呢就有点虚啊，为了以后理直气壮的回答面试问题，所以准备好好把这个问题弄清楚，问题总是会有的，慢慢解决就好了。 软件包 java.lang.ref提供了引用对象类，支持在某种程度上与垃圾回收器之间的交互。程序可以使用一个引用对象来维持对另外某一对象的引用，所采用的方式是使后者仍然可以被回收器回收。程序还可以安排在回收器确定某一给定对象的可到达性已经更改之后的某个时间得到通知。我们都知道 JVM 中对象是被分配在堆（heap）上的，当程序行动中不再有引用指向这个对象时，这个对象就可以被垃圾回收器所回收。包结构如下图： 引用类型引用类型（reference type）指向一个对象，不是原始值，指向对象的变量是引用变量。在java里面除去基本数据类型的其它类型都是引用数据类型，自己定义的class类都是引用类型。123456789101112131415161718192021引用对象的抽象基类。此类定义了常用于所有引用对象的操作。因为引用对象是通过与垃圾回收器的密切合作来实现的，所以不能直接为此类创建子类。public abstract class Reference&lt;T&gt; &#123; private T referent; /* Treated specially by GC */ ... public T get() &#123; return this.referent; &#125; public void clear() &#123; this.referent = null; &#125; ... Reference(T referent) &#123; this(referent, null); &#125; Reference(T referent, ReferenceQueue&lt;? super T&gt; queue) &#123; this.referent = referent; this.queue = (queue == null) ? ReferenceQueue.NULL : queue; &#125;&#125; StrongReference 强引用 强引用可以直接访问目标对象。 强引用所指向的对象在任何时候都不会被系统回收。 强引用可能导致内存泄漏(out of memory)。实际上，FinalReference 代表的正是 Java 中的强引用，如这样的代码 :1Bean bean = new Bean(); 在虚拟机的实现过程中，实际采用了 FinalReference 类对其进行引用。而 Finalizer，除了作为一个实现类外，更是在虚拟机中实现一个 FinalizerThread，以使虚拟机能够在所有的强引用被解除后实现内存清理。整个FinalReference类的定义如下：123456789101112131415161718192021222324252627class FinalReference&lt;T&gt; extends Reference&lt;T&gt; &#123; public FinalReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125;&#125;final class Finalizer extends FinalReference&lt;Object&gt; &#123; ... private void runFinalizer(JavaLangAccess jla) &#123; synchronized (this) &#123; if (hasBeenFinalized()) return; remove(); &#125; try &#123; Object finalizee = this.get(); if (finalizee != null &amp;&amp; !(finalizee instanceof java.lang.Enum)) &#123; jla.invokeFinalize(finalizee); /* Clear stack slot containing this variable, to decrease the chances of false retention with a conservative GC */ finalizee = null; &#125; &#125; catch (Throwable x) &#123; &#125; super.clear(); &#125; ...&#125; 软引用 SoftReference 在响应内存需要时，由垃圾回收器决定是否清除此对象。如果内存充足，则垃圾回收器不会回收该对象，如果内存不够了，就会回收这些对象的内存。 软引用对象最常用于实现内存敏感的缓存 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。1234567891011121314151617181920212223242526272829303132333435363738394041SoftReference类源代码public class SoftReference&lt;T&gt; extends Reference&lt;T&gt; &#123; static private long clock; private long timestamp; public SoftReference(T referent) &#123; super(referent); this.timestamp = clock; &#125; public SoftReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); this.timestamp = clock; &#125; public T get() &#123; T o = super.get(); if (o != null &amp;&amp; this.timestamp != clock) this.timestamp = clock; return o; &#125;&#125;//SoftReference测试代码public class Test &#123; public static void main(String[] args) &#123; SoftReference&lt;Userx&gt; bean = new SoftReference&lt;Userx&gt;(new Userx(&quot;name&quot;, 10)); //返回此引用对象的指示对象。如果此引用对象已经由程序或垃圾回收器清除，则此方法将返回 null bean.get().say(); &#125;&#125;//Userx类public class Userx &#123; private String name; private int age; public Userx(String name, int age) &#123; this.name = name; this.age = age; &#125; public void say() &#123; System.out.println(&quot;my name is: &quot; + name + &quot;, age is: &quot; + age); &#125;&#125;每一个对象通过软引用进行实例化，这个对象就以cache的形式保存起来，当再次调用这个对象时，那么直接通过软引用中的get（）方法，就可以得到对象中中的资源数据，这样就没必要再次进行读取了，直接从cache中就可以读取得到，当内存将要发生OOM的时候，GC会迅速把所有的软引用清除，防止oom发生。 弱引用 WeakRefrence 用来描述非必须的对象，但是它的强度比软引用更弱一些 被弱引用关联的对象只能生存到下一次垃圾收集发送之前 当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象 一旦一个弱引用对象被垃圾回收器回收，便会加入到一个注册引用队列中123456789101112WeakRefrence源代码，只是继承了抽象类public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; &#123; //创建引用给定对象的新的弱引用。新的引用没有向任何队列注册。 public WeakReference(T referent) &#123; super(referent); &#125; //创建引用给定对象的新的弱引用，并向给定队列注册该引用。 public WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125;&#125; 虚引用PhantomReference 一个持有虚引用的对象，和没有引用几乎是一样的，随时都有可能被垃圾回收器回收 虚引用的最大作用在于跟踪对象回收，清理被销毁对象的相关资源。 随时都有可能被垃圾回收器回收12345678910PhantomReference源代码，可以看到它的get方法返回的是nullpublic class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123; public T get() &#123; return null; &#125; public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125;&#125; 自动清除引用在将软引用和弱引用添加到向其注册的队列（如果有）之前，回收器将自动清除这些引用。所以，软引用和弱引用不需要向队列注册即可使用，而虚引用则需要这样做。通过虚引用可到达的对象将仍然保持原状，直到清除所有这类引用或者它们本身变得不可到达。 参考链接blog深入探讨 java.lang.ref 包java引用类型","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"引用","slug":"引用","permalink":"http://yoursite.com/tags/引用/"}]},{"title":"spring aop 使用以及代理原理","date":"2017-03-10T11:09:30.000Z","path":"2017/03/10/springaop/","text":"前言又到了紧张刺激的前言了，前一段时间整理了hashmap以及解决hash碰撞的方法，然后今天在阿里第一次面试的时候就问到了。虽然这个回答的还可以，但是我对自己还是失望的，面试问我spring和主要概念aop我知不知道。讲真的，我老早就说准备看看，而且我还看过一遍，但是就只是那么匆匆一看，没有怎么在意。果然就像考试，只有仔细认真的人才会一直取得高分。所以我今天一天都在研究spring aop。 使用场景面向切面区别于面向对象，由于琐碎的逻辑需要嵌入整体的项目框架。如果是面向对象需要在相应的对象中修改代码，这样显然很麻烦，而且琐碎的逻辑耦合在了项目中。如果使用面向切面，就可以减少耦合。通过面向切面可以不用修改原有项目代码，而是在外部找到添加代码，找到需要嵌入逻辑的地方标记好，那么运行的时候就会插入相应的代码。比如我们常用的如事务管理、安全检查、缓存、对象池管理。AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理. 实践出真知启用 Spring 对 @AspectJ 方面配置的支持12在config类中添加@EnableAspectJAutoProxy注解当启动了 @AspectJ 支持后，只要我们在 Spring 容器中配置一个带 @Aspect 注释的 Bean，Spring 将会自动识别该 Bean，并将该 Bean 作为切面 Bean 处理。 定义切面12345678910111213141516171819202122232425262728293031@Aspectpublic class TestAspect &#123; @Before(&quot;execution(* com.example.web.LoginControlller.well(..))&quot;) public void logBefore(JoinPoint joinPoint) &#123; System.out.println(&quot;logBefore() is running!&quot;); System.out.println(&quot;hijacked : &quot; + joinPoint.getSignature().getName()); System.out.println(&quot;******&quot;); &#125; @After(&quot;execution(* com.example.web.LoginControlller.well(..))&quot;) public void logAfter(JoinPoint joinPoint) &#123; System.out.println(&quot;logAfter() is running!&quot;); System.out.println(&quot;hijacked : &quot; + joinPoint.getSignature().getName()); System.out.println(&quot;******&quot;); &#125; @AfterReturning( pointcut = &quot;execution(* com.example.web.LoginControlller.well(..)))&quot;, returning= &quot;result&quot;) public void logAfterReturning(JoinPoint joinPoint, Object result) &#123; System.out.println(&quot;logAfterReturning() is running!&quot;); System.out.println(&quot;hijacked : &quot; + joinPoint.getSignature().getName()); System.out.println(&quot;Method returned value is : &quot; + result); System.out.println(&quot;******&quot;); &#125;&#125; 定义控制器1234567@RestControllerpublic class LoginControlller &#123; @RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST) public String login (@PathVariable String post) &#123; System.out.println(&quot;login() is running &quot;); return &quot;hah&quot;; &#125; 输出1234567891011logBefore() is running!hijacked : well******get() is running logAfter() is running!hijacked : well******logAfterReturning() is running!hijacked : wellMethod returned value is : well****** spring aop 的代理模式12345Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than interfaces. CGLIB is used by default if a business object does not implement an interface. As it is good practice to program to interfaces rather than classes; business classes normally will implement one or more business interfaces. It is possible to force the use of CGLIB, in those (hopefully rare) cases where you need to advise a method that is not declared on an interface, or where you need to pass a proxied object to a method as a concrete type.It is important to grasp the fact that Spring AOP is proxy-based. See Section 11.6.1, “Understanding AOP proxies” for a thorough examination of exactly what this implementation detail actually means. 这是官网对于spring aop代理的描述，这里可以看到 静态代理：使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；静态代理以 AspectJ 为代表。 动态代理：在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。Spring AOP 用的就是 动态代理 动态代理 如果目标对象实现了接口，默认会采用JDK的动态代理机制实现AOP 如果目标对象实现了接口，可以强制使用CGLIB实现AOP 如果目标对象没有实现接口，必须使用CGLIB生成代理，spring会自动在CGLIB和JDK动态代理之间切换 JDK代理只能对实现了接口的类生成代理，而不能针对类 CGLIB是针对类实现代理的，主要对指定的类生成一个子类，并覆盖其中的方法 原理解析AOP 代理其实是由 AOP 框架动态生成的一个对象，该对象可作为目标对象使用。AOP 代理包含了目标对象的全部方法，但 AOP 代理中的方法与目标对象的方法存在差异：AOP 方法在特定切入点添加了增强处理，并回调了目标对象的方法。代理类图： JDK动态代理sping aop的jdk动态代理主要基于JdkDynamicAopProxy实现源代码如下：1234567891011121314final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable &#123; ... //创建一个代理对象 @Override public Object getProxy(ClassLoader classLoader) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource()); &#125; Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this); &#125; ...&#125; 从源代码中我们可以看出这个类实现了AopProxy和InvoctionHandler接口。12345678910111213141516而这个AopProxy中只定义了两个方法。这个接口是在spring中定义的。public interface AopProxy &#123; Object getProxy(); Object getProxy(ClassLoader classLoader);&#125;这个InvocationHandler接口是在jdk中定义的，其中只有一个方法invoke。* InvocationHandler 是代理实例的调用处理程序 实现的接口* 包名可以看出使用到了反射* 每个代理实例都具有一个关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程序的 invoke 方法。package java.lang.reflect;public interface InvocationHandler &#123; //在代理实例上处理方法调用并返回结果。 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; 12345678910在JdkDynamicAopProxy中getProxy最后使用的方法是return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);这个方法是Proxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。@CallerSensitivepublic static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; ...&#125; JDK动态代理demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//接口package com.example.test;/** * Created by xiezhanghua on 2017/3/11. */public interface Student &#123; void say();&#125;//实体类package com.example.test;/** * Created by xiezhanghua on 2017/3/11. */public class StudentImpl implements Student &#123; private String name; public StudentImpl() &#123; &#125; public StudentImpl(String name) &#123; this.name = name; &#125; @Override public void say() &#123; System.out.println(&quot;my name is: &quot; + name); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;//代理工厂类package com.example.test;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * Created by xiezhanghua on 2017/3/11. */public class ProxyFactory implements InvocationHandler &#123; private Object obj; public Object createObjectProxy(Object obj) &#123; this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; StudentImpl stu = (StudentImpl) obj; Object object = null; if(stu.getName() != null) object = method.invoke(stu, args); else System.out.println(&quot;i am the proxy of student&quot; + &quot;his name is &quot; + stu.getName()); return object; &#125;&#125;//展示package com.example.test;/** * Created by xiezhanghua on 2017/3/11. */public class Test &#123; public static void main(String args[]) &#123; Student stu = (Student) new ProxyFactory().createObjectProxy(new StudentImpl()); stu.say(); Student stu2 = (Student) new ProxyFactory().createObjectProxy(new StudentImpl(&quot;xiezhanghua&quot;)); stu2.say(); &#125;&#125;//输出i am the proxy of studenthis name is nullmy name is: xiezhanghua CGLIB代理spring 使用cglib代理的类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class CglibAopProxy implements AopProxy, Serializable &#123;@Overridepublic Object getProxy(ClassLoader classLoader) &#123; ... try &#123; ... // Configure CGLIB Enhancer... Enhancer enhancer = createEnhancer(); if (classLoader != null) &#123; enhancer.setClassLoader(classLoader); if (classLoader instanceof SmartClassLoader &amp;&amp; ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123; enhancer.setUseCache(false); &#125; &#125; //设置父类 enhancer.setSuperclass(proxySuperClass); enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised)); enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE); enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader)); Callback[] callbacks = getCallbacks(rootClass); Class&lt;?&gt;[] types = new Class&lt;?&gt;[callbacks.length]; for (int x = 0; x &lt; types.length; x++) &#123; types[x] = callbacks[x].getClass(); &#125; // fixedInterceptorMap only populated at this point, after getCallbacks call above enhancer.setCallbackFilter(new ProxyCallbackFilter( this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset)); enhancer.setCallbackTypes(types); // Generate the proxy class and create a proxy instance. return createProxyClassAndInstance(enhancer, callbacks); &#125; ... protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) &#123; enhancer.setInterceptDuringConstruction(false); //设置回调函数 enhancer.setCallbacks(callbacks); return (this.constructorArgs != null ? enhancer.create(this.constructorArgTypes, this.constructorArgs) : enhancer.create()); &#125; ...&#125;&#125; 主要注意的地方就是Enhancer类的使用.在创建的时候，我们要使用一个 Enhance 类的对象，而不再是 Proxy，需要为其实例指定一个父类，也就是我们 的目标对象。这样，我们新创建出来的对象就是目标对象的子类，有目标对象的一样。除此之外，还要指定一个回调函数，这个函数就和Proxy的 invoke()类似。 总体来说，使用CGlib的方法和使用Proxy的方法差不多，只是Proxy创建出来的代理对象和目标对象都实现了同一个接口。而CGlib的方法则是直接继承了目标对象。 Enhancer 参考链接spring 官方文档spring aop使用aop设计模式natian306的专栏Enhancer链接","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"hashmap 源码分析","date":"2017-03-07T13:49:49.000Z","path":"2017/03/07/hashmap/","text":"前言我发现了，写博客什么的最有意思的时候还是写前言来的开心。反正就是瞎嗨为什么动笔。为什么写这个是因为今天面试的时候问当了下面这段代码中构造函数中的参数数是干嘛用的，问这个问题我当时很羞愧，其实有的时候自己也会去问为什么有这么多构造函数，具体应用场景是什么，然后就是没有刨根问底的精神。现在我就来刨根问底下也不晚吧，😂 所问代码可以看到构造函数中都可以传入参数 threshold：阈值，用于判断是否需要调整容量。threshold的值=”容量*加载因子” loadFactor：加载因子，通常设为0.75 HashMap源代码为例子分析Java.util.Hashtable类实现了JAVA中的哈希表，内部采用Node[]数组，每个Node均可作为链表的头，用来解决哈希碰撞。 特点 基于哈希表的 Map 接口的实现。 允许使用 null 值和 null 键。 此类不保证映射的顺序。 Node类 源码123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 构造函数12345678910111213141516171819202122232425 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;/** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 扩容通常，默认加载因子 (.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 参考资料 jdk8api jdk源码","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"}]},{"title":"几种解决hash碰撞的方法","date":"2017-03-07T12:21:27.000Z","path":"2017/03/07/hash/","text":"前言又到了胡说八道时间，今天晚上接到携程电话面试（暑期实习面试），但是我正在填写银联数据的试卷（话说我面试已经过了，只要笔试过了就可以了，然而接了个电话，gg）。为什么写这个是因为今天面试问到我如何解决hash碰撞，学习知识才是王道。 哈希碰撞哈希碰撞是不同的key通过哈希函数以后得到了相同的value值。原理图如下： 拉链法Java标准库的HashMap和HashTable基本上就是用拉链法实现的。拉链法的实现比较简单，将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。原理图如下： 步骤： 通过key算出hash值 通过hash值找到地址 如果地址为空，直接添加 如果地址不为空，插入表头 线性探测法线性探索法是最简单的解决hash碰撞的方法。他把散列表当作一个循环数组看待。原理图如下： 步骤： 通过key算出hash值 通过hash值找到地址 如果地址为空，直接添加 如果地址不为空，地址++，回到上一步，循环的顺序是0-n-1-0 双重哈希法hi=(h(key)+ih1(key))％m 0≤i≤m-1 //即di=i*h1(key) ，也就是使用两个哈希函数 再哈希法简单的点说就是如果hash函数1发生冲突就换一个hash函数2 建立公共溢出区这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表 ##参考链接blog1blog2","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"}]},{"title":"泰国游记 第一天1.16 by yuan同学 and zhou同学","date":"2017-03-02T11:37:41.000Z","path":"2017/03/02/taiday1/","text":"zhou同学版 yuan同学版 第一天1.16出发时间：凌晨3：00（携程接机），40分钟抵达上海浦东国际机场，办理托运和登机牌时遇到泰国来华留学生，在候机的地方给我们推荐当地特色和美食，并且帮助我们修改行程计划。(真的超级幸运，整个旅行给我们提供了很多帮助)6：50飞机起飞，十点半到达廊曼机场；注意在机场填写出入境卡，好好保存出境卡（回国时需要）更换电话卡，一行六人分开打的士前往预定的民宿，之前看攻略说一定要by meter！,然而完全没有什么用，曼谷的出租车司机有的是办法让你的出租车费用飞起来！比如走高速，绕路…… 机场——民宿Taxi1 210TB 高速费+出租费+小费Taxi2 100TB 出租费105-没有零钱省下的5TB还好还好~~ 民宿——大皇宫Taxi1 250TB 出租费Taxi2 380TB 高速费+出租费What!? 大皇宫——-民宿Taxi1 330TB 出租费（司机不认识路，饶路，已经偏贵Taxi2 510TB 高速费+出租费+…（小剧场：我们：可以不走高速吗？走下面司机：不行！不走高速到不了！我们：……)Whaaaaaat!?只想说算你们狠!!!!午餐当地、meji牛奶下午原定行程是大皇宫。但不让进了，遗憾。外面看起来就很壮观！改成卧佛寺、拍照（国王丧期，国民祭祀）晚上考山路、酒吧（center khao saim）、小吃、砍价、买东西 教训：坑货司机，400RMB 关键词：taxi、便宜、彩色（国王颜色，待查证） 、舞蹈 餐饮中午吃的：鸡腿、牛肉串（不知道叫什么），蔬菜生的配肉和酱，这个酱好辣啊很多材料都没怎么处理，总共510B下午吃的：路边各种免费饮料，应该是国王祭祀期间送的、芒果（不是很甜100B）晚上吃的：榴莲180B（第一次吃，还挺好吃的））、热带水果拼盘50B两份（火龙果、芒果、木瓜）、pad thai50B（虾仁，加一句，这边的虾不要钱的样子，什么里面都加）、椰奶冰淇淋，有椰肉好吃的50B，酒吧各种好吃的1470B 建议：1.酒吧要选人多的，有欧洲人莫名就起舞了，很多人都会上去跳舞。泰国的酒普遍比国内贵一些。2.榴莲要选软的，颜色偏淡，饱满的，并不便宜3.曼谷check in 3点以后，自己定的民宿可以联系房东，（airbnb上预定的）4.建议住民宿，房东让我们早check in，让我们寄存东西，免费送我们去机场，常常受到我们的电话骚扰。泰国人十分守时，一般只会提前到，所以有拖延症的小伙伴要提前准备。5.司机巨坑，建议能不上高速就不上高速，过高速的费用都是我们出（有点贵🌚），建议接机和包车6.大皇宫8:30-3:30，我们去的时候太晚了，没办法去大皇宫，很遗憾7.国际航空挺稳定，位子也还挺宽的。泰国国内航空位子窄。8.大皇宫那边有专门的志愿者帮助你找路和提供线路建议。不要听信路边收费的旅行指导。 故事1.老夫妻的舞蹈2.护照丢失奇案，主人公（汪小明）","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"travel","slug":"travel","permalink":"http://yoursite.com/tags/travel/"},{"name":"thailand","slug":"thailand","permalink":"http://yoursite.com/tags/thailand/"}]},{"title":"二叉查找树","date":"2017-03-02T10:46:02.000Z","path":"2017/03/02/TreeMap/","text":"前言本来是准备了解下HashMap特点的，最后又看到源码，然后就想知道底层原理是什么。发现又遇到了红黑树这个概念，以前一直有遇到，但是每次看了一点点就放弃了。有句话不是说：今生的是一个回首是因为上辈子500次插肩而过。我得到的结论就是如果想撩到自己喜欢的妹子，那就要多几次插肩而过，所以我决定和二叉查找树，多联络联络感情。😂😂😂 特点：二叉查找树满足按序搜索的性质，即对于树中的每个节点X，所有在X左子树中的元素的键值都比X的键值小，所有在X右子树中元素的键值逗逼X的键值要大。 操作 find：从根开始，根据比较的结果，走左分支或右分支 findMin操作时只要有左孩子就搜索左分支，findMax也是类似。 remove操作时很困难的，因为非叶子结点奖树连接在一起，而我们不希望断开这棵树 如果一个结点只有一个孩子，通过让它的父节点跳过它来删除它。 删除一个具有两个孩子的节点，只要用它右子树中最小的项来代替它。然后删除原来的右子树的最小节点。 TreeMap特点： 实现了red 实现了red-black树结构。 查找、插入和删除的时间复杂度是 $log\\left ( n \\right )$。 TreeMap 对象这方面比BinSearchTree对象高级，与AVLTree对象不相上下。 元素按照键的顺序存储。 红黑树 （red-black-tree）参考书籍《数据结构和java集合框架》","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"Tree","slug":"Tree","permalink":"http://yoursite.com/tags/Tree/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"java 算法 （搜索算法 二分排序）","date":"2017-02-28T12:30:19.000Z","path":"2017/02/28/searchAlgorithm/","text":"二分搜索算法二分搜索算法顾名思义就是每次分成两边的搜索算法，这个算法的要求是数据已经是排序过的数据。 步骤 排序 比较中值和搜索值大小，化分搜索范围 对划分的范围继续搜索 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** 不是迭代的二分搜索算法 */public static int binarySearch(int[] arr, int low, int high,int search) &#123; System.out.println(&quot;&quot;); while (low &lt;= high) &#123; int mid = (low + high) / 2; if (search &gt; arr[mid]) &#123; low = mid + 1; System.out.println(&quot;mid: &quot; + mid + &quot;high: &quot; + high + &quot;low: &quot; + low); &#125; else if (search &lt; arr[mid]) &#123; high = mid - 1; System.out.println(&quot;mid: &quot; + mid + &quot;high: &quot; + high + &quot;low: &quot; + low); &#125; else &#123; System.out.println(&quot;找到的数据在第&quot; + mid + &quot;值为：&quot; + arr[mid]); return arr[mid]; &#125; &#125; System.out.println(&quot;无此数据&quot;); return -1;&#125;/** 二分迭代搜索算法 */public static int binaryItratorSearch(int[] arr, int low, int high, int search) &#123; System.out.println(&quot;&quot;); if (low &lt;= high) &#123; int mid = (low + high) / 2; if (search &lt; arr[mid]) &#123; high = mid -1; System.out.println(&quot;mid: &quot; + mid + &quot;high: &quot; + high + &quot;low: &quot; + low); binaryItratorSearch(arr, low, high, search); &#125; else if (search &gt; arr[mid]) &#123; low = mid + 1; System.out.println(&quot;mid: &quot; + mid + &quot;high: &quot; + high + &quot;low: &quot; + low); binaryItratorSearch(arr, low, high, search); &#125; else &#123; System.out.println(&quot;找到的数据在第&quot; + mid + &quot;值为：&quot; + arr[mid]); return arr[mid]; &#125; &#125; System.out.println(&quot;无此数据&quot;); return -1;&#125;","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"java 面试遇到的问题","date":"2017-02-28T04:56:15.000Z","path":"2017/02/28/javaPaper/","text":"前言：突然发现我现在写blog喜欢写些原因，最近有可能是在图书馆听着民谣，效率更高吧。我写这个就是想着把自己面试遇到的一些小问题整理下，方便自己以后看看，以方便以后别人面试的时候遇到。 java 初始化块、静态初始化块、构造函数初始化理解Java中的类初始化 static 关键字 当声明一个事物为static时，就意味着这个域或方法不会与包含它的类的任何对象实例关联在一起。 即使从未创建某个类的任何对象，也可以调用其static方法或访问其static域 equals 和 ==在Object中，使用equals方法和使用“==”运算符是完全等价的，不过许多类重写了Object类的equals方法，String类也是如此。重写后比较的是值而不是地址。 注意： String类是不可变的，String类一旦创建久不可改变。 String类采用字符串常量池是合理的，因为String是非可变的，即使多个引用指向同一个String对象，也不会导致一份对象改变影响另外的对象。 使用String类的场景：在字符串不经常变化的场景中可以使用String类，例如常量的声明、少量的变量运算。 使用StringBuffer类的场景：在频繁进行字符串运算（如拼接、替换、删除等），并且运行在多线程环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装。 使用StringBuilder类的场景：在频繁进行字符串运算（如拼接、替换、和删除等），并且运行在单线程的环境中，则可以考虑使用StringBuilder，如SQL语句的拼装、JSON封装等。 public static void main(String[] args)这样定义的原因 public main方法在程序启动的时候有jvm调用，所以应声明为public static 静态方法，方法被调用，要么使用对象实例引用访问，要么声明为static，使用类直接调用。main方法声明为static这样就无需生成对象实例，直接使用jvm调用。 void 无返回类型 String[] args 用户输入参数 java 8种基本数据类型 byte 字节型 8位 char 字符型 16位 short 短整型 16位 int 整型 32位 long 长整型 64位 float 浮点型 32位 double 双浮点型 64位 boolean 布尔型 true false 包装类 拆装箱问题java中的基本数据类型不是对象，因为这些数据使用简便，如果作为对象处理，每次使用都需要在堆上分配空间，然后在不需要的时候由垃圾回收器来清理，会照成很大的资源浪费。 解决的是将基本数据类型和包装类的转换。1234567891011121314151617181920212223HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); // HashMap&lt;String, int&gt; map = new HashMap&lt;String, int&gt;(); 会报错误map.put(&quot;test1&quot;, 11);map.put(&quot;test2&quot;, 12);for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; System.out.println(&quot;key:&quot; + entry.getKey() + &quot; value:&quot; + entry.getValue());&#125;long t = System.currentTimeMillis();Long sum = 0L;for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum += i;&#125;System.out.println(&quot;total:&quot; + sum);System.out.println(&quot;processing time: &quot; + (System.currentTimeMillis() - t) + &quot; ms&quot;);long t1 = System.currentTimeMillis();long sum1 = 0L;for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum1 += i;&#125;System.out.println(&quot;total:&quot; + sum1);System.out.println(&quot;processing time: &quot; + (System.currentTimeMillis() - t1) + &quot; ms&quot;); java 流InputStream OutputStream 8位 操作二进制数据Reader Writer 16位 以Unicode字符为单位从stream读取或往stream写入InputStreamReader 将InputStream转换为ReaderOutputStreamWriter 将OutputStream转换为Writer1.标准输入输出 2.文件操作 3.网络上数据流 4.字符串流 5.对象流 6.zip文件流 blog 参考资料《java编程思想》《细说java》jdk8知乎","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"初步接触jvm","date":"2017-02-27T10:42:49.000Z","path":"2017/02/27/jvm/","text":"ps：本来最近在弄nginx方面的东西，结果接到了SAP的电话面试，面试的java方面的知识，感觉自己对于jvm方面的知识了解有限，所以决定学习下jvm，刚好前段时间看到了《初探java虚拟机》这本书，那么接下来的学习笔记基本是以这本书为材料。 虚拟机的基本结构 虚拟机架构类加载子系统负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。方法区还存放运行时常量池信息，包括字符串字面量和数字常量。 java堆在虚拟机启动的时候建立，它是java程序最重要的内存工作区域。几乎所有的实例都放在java堆中。堆空间是线程共享的，这是一块与java应用密切相关的内存区间。 java的NIO库允许java程序使用直接内存。直接内存是在java堆外的、直接向系统申请的内存空间。通常直接内存的速度会优于java堆。由于直接内存在java堆外，因此它的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给的最大内存。 垃圾回收系统是java虚拟机的重要组成部分，垃圾回收器可以对方法区、java堆和直接内存进行回收。其中，java堆是垃圾收集器的工作重点。和c/c++不同，java中所有的对象空间释放都是隐式的。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成java堆、方法区和直接内存的全自动化管理。 每一个java虚拟机线程都有一个私有的java栈。一个线程的java栈在创建的时候被创建。java栈中保存着局部变量、方法参数，同时和java方法的调用、返回密切。 本地方法栈和java栈非常相似，最大的不同在于java栈用于java方法的调用，而本地方法栈则用于本地方法调用。作为对java虚拟机的重要扩展，java虚拟机允许java直接调用本地方法（通常使用c编写）。 PC(program counter)寄存器也是每个线程私有的空间，java虚拟机会为每一个java线程创建PC寄存器。在任意时刻，一个java线程总是在执行一个方法，这个正在执行的方法成为当前方法。如果当前方法不是本地方法，pc寄存器就会指向当前正在执行的指令。如果当前方法是本地方法，那么pc寄存器的值就是undefined。 执行引擎室java虚拟机的核心组件之一，负责执行虚拟机的字节码。 函数调用：出入java栈 java栈是一块私有的内存空间。可以说java堆和程序数据密切相关，java栈是和线程执行相关的。先入先出的结构，函数返回的时候，栈帧从java栈中弹出。 提示：由于每次函数调用都会生成对应的栈帧，从而占用一定的栈空间，因此，如果请求的栈深度大于最大可用栈深度时，系统就会抛出stackoverflowerror栈溢出的问题。 局部变量表局部变量表时栈帧的重要组成部分。用于保存函数的参数以及局部变量。局部变量只在当前函数中有效，当函数调用结束以后，随着函数栈帧的销毁，局部变量也会随之销毁。只要局部变量表中直接或间接引用的对象都是不会回收的。因此，理解局部变量表对理解垃圾回收有一定帮助。 Class文件结构 文件以一个4字节的Magic开头，紧跟着两个大小版本号 在版本号之后是常量池，常量池的个数位constant_pool_count。 常量池之后是类的访问修饰符、代表自身类的引用、父类引用以及接口数量和实现的接口引用。 在接口之后，有字段数量和字段描述、方法数量以及方法描述。 最后放着类文件的属性信息。 注意：高版本的java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的java虚拟机不能执行高版本编译器生成的Class文件。 参考书籍《初探Java虚拟机》","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}]},{"title":"nginx","date":"2017-02-27T07:29:54.000Z","path":"2017/02/27/nginx/","text":"前段时间买了一个阿里云服务器，由于是学生特价，还挺实惠的。然后过年期间就一直没去弄他，备案也差最后照相没去弄，找个时间把这个弄了。所以想着可以玩玩服务器，这段时间没怎么接错linux方面的知识，刚好借助这个机会熟悉下。拿到服务器，开始的时候是一脸萌比的，里面什么都没有，所以需要自己安装相应的软件。 第一步 远程登录参考blog阿里帮助文档使用iterm2 在本地配置好了，就可以ssh免密登陆到阿里云服务器了。 第二步 安装 nginx步骤12345678* yum -y install nginx* /etc/init.d/nginx start 这个地方会报错，nginx：nginx: [emerg] socket() [::]:80 failed (97: Address family not supported by protocol)解决方案： * vim /etc/nginx/conf.d/default.conf * 注释 [::]:80 default_server* /etc/init.d/nginx restart* 访问ip 第三步，nginx 配置文件构成1234567891011121314151617181920......events&#123;......&#125;https&#123;...... server &#123; ...... &#125; server &#123; ...... &#125; ......&#125; 第四步 nginx 压缩输出配置1234567891011121314151617181920gzip on 开启gzip模块gzip_buffers number size 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。gzip_min_length 设置允许压缩的页面最小字节流，建议大于1K压缩。gzip_http_version 1.0| 1.1 是别http版本gzip_proxied [off|expired|no-cache|no-store...] nginx作为反向代理的时候启用开启或关闭后端服务器返回的结果。gzip_type mime-type 匹配mime类型进行压缩demohttp&#123;include conf/mime-type;gzip on;gzip_min_length 1000;gzip_buffers 4 8K;gzip_http_version 1.1;gzip_type text/plain application/x-javascript text/css text/html application/xml;......&#125; 第五步 nginx 的浏览器本地缓存设置12345678location ~ .*/.(git | jpg | jpeg | png | bmp | sef)$&#123; expires 30d;&#125;location ~ .*/.(js | css)?$&#123; expires 1h;&#125; 参考资料《实战Nginx》《Nginx Http server》","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"java 算法 （排序算法 快速排序）","date":"2017-02-24T05:44:19.000Z","path":"2017/02/24/quickSort/","text":"ps:今天听了一首感动死我的歌，歌曲名是Bressanone（布列瑟农），听的时候全身鸡皮疙瘩都起来了，然后我就去搜这首歌，谁知道还有一个感人的故事。以下是作者自述，链接来着一个音乐推荐网站音乐链接 快速排序（Quick Sort）听着音乐差点都忘记了主题了，这篇blog的主题是快速排序。 思想：快速排序由C.A.R.Hoare （1962）开发的，算是分治算法的一种。该算法在数组中选择一个主元（pivot）的元素将数组分为两部分，使得第一部分中所有元素都小于或等于主元，而第二部分中的所有元素都大于主元。对第一第二部分递归调用。步骤： 取pivot 划分两部分 递归调用划分方法 具体代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** 快速排序*/public static void quickSort(int[] arr) &#123; System.out.println(&quot;&quot;); System.out.println(&quot;快速排序前的数组为： &quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125; quickSort(arr, 0, arr.length - 1); System.out.println(&quot;&quot;); System.out.println(&quot;快速排序后的数组为：&quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125;&#125;private static void quickSort(int[] arr, int first, int last) &#123; if (last &gt; first) &#123; int pivot = partition(arr, first, last); quickSort(arr, first, pivot - 1); quickSort(arr, pivot + 1, last); &#125;&#125;private static int partition(int[] arr, int first, int last) &#123; int pivot = arr[first]; // 主元 int low = first + 1; int high = last; while (high &gt; low) &#123; while (low &lt;= high &amp;&amp; arr[last] &lt;= pivot) &#123; low++; &#125; while (low &lt;= high &amp;&amp; arr[high] &gt; pivot) &#123; high--; &#125; if (high &gt; low) &#123; int temp = arr[high]; arr[high] = arr[low]; arr[low] = temp; &#125; &#125; while (high &gt; first &amp;&amp; arr[high] &gt;= pivot) &#123; high--; &#125; if (pivot &gt; arr[high]) &#123; arr[first] = arr[high]; arr[high] = pivot; return high; &#125; else &#123; return first; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455马修·连恩—布列瑟农谢谢你的评论，现在给你自己冲杯热茶，坐好，我接下来给你说个关于bressanone的故事......几年前，我疯狂地爱上了一个年轻的女孩，还有，也爱上了南部蒂罗尔山区，它在意大利的北部，与奥地利接壤，就在勃伦尔山脉的南边（勃伦尔山脉正好把意大利和奥地利分隔开来）。南部蒂罗尔曾经跟北部蒂罗尔（现在属于奥地利）和西部蒂罗尔（现在属于瑞士）是一个整体。这个地区的人说的是德国的一种方言，但是由于蒂罗尔被分割开来，而南部蒂罗尔变成意大利的一部分，所以这里的地名一般都有意大利文和德文两种名字。总之呢...许多年前我给绿色和平组织工作，在那时候我遇上了一个让我心动的女孩子。我们是在加州的约塞米蒂国家公园归途中相遇的。自那以后，她回到科罗拉多州的绿色和平组织，最后回到纽约洲去上学，而我则回到圣迭戈的绿色和平组织，并且最后回到我在加拿大育空地区的老家。此后的几个月里我们不停地通讯。很快我们都希望能有更进一步的发展。她将要去意大利的佛罗伦萨学习艺术，我就要去德国的慕尼黑开始新的表演生活，跟一支叫“三月粉”的摇滚乐队...哈啊，没错，三月粉...那是另外一个故事了。当我俩都在欧洲的时候，我们选了一个处在佛罗伦萨和慕尼黑之间的地方约会。这就是南部蒂罗尔的一个小镇，德文里面它叫“Brixen”，意大利文就是“bressanone”。Bressanone是个非常优美的小镇。它被小乡村包围着，而山谷中回响着教堂的钟声，山羊在牧场漫步，远处是高耸的白色山头。我们在那里玩乐了几天，探索过周围的小乡村，还有彼此的心。离别的日子到了，她要回去的时候我陪着她去附近乡村的火车站，真是很令人沮丧啊，我们都要踏上各自的道路。流着泪水，我上了去火车站的公共汽车，在短短的40分钟路程里，我缓缓入睡了，在梦中，我隐隐约约地似乎听到了这样的一首歌，非常美妙的旋律和歌词。我醒来的时候，赶紧下了车，来到最近的咖啡店，把所听到的旋律和歌词写在一张餐巾纸上，好让我能够永远地记住它。一年以后，我才有机会把这首歌录下来。在我的心里，永远会留个地方是给她，还有那些小乡村，和这首歌。谢谢你这么认真地听我说。现在...是时候跟你同睡了，晚安!!!:-)马修附原文：The Storyby Matthew LienDate: 02-20-02 18:10Hello Forrest,Thank you for your comments. Now make yourself a cup of hot tea, sit back, and I&apos;ll tell you a story about Bressanone...Several years ago, I fell deeply in love with a young woman, and also with a part of northern Italy known as South Tyrol. It borders Austria, just south of the Brenner mountain pass which separates Italy from Austria.South Tyrol used to be joined with North Tyrol (now a part of Austria) and West Tyrol (now a part of Switzerland). The people of this area speak a dialect of German. But since Tyrol was divided and South Tyrol became a part of Italy, all the place names are in both German and Italian.Anyway... I once worked for Greenpeace many years ago, where I met a young woman who melted my heart. We met while on a retreat in California&apos;s Yosemite National Park. After the retreat, she returned to the Colorado Greenpeace office, and eventually went back to school in New York state. I returned to the San Diego Greenpeace Office, and eventually went back to my home in the Yukon, Canada.Over the months we stayed in touch. Soon we discovered that we would both be close again. She was going to study art in Florence, Italy, and I was going to live in Munich, Germany performing with a rock band called &quot;Marching Powder&quot;... ahhhh yes, Marching Powder... but that&apos;s another story.When we were both in Europe, we made arrangements to meet in a place that was close to being between Florence and Munich. This was the South Tyrolian town called &quot;Brixen&quot; in German, or &quot;Bressanone&quot; in Italian. Bressanone is a beautiful town surrounded by small villages high in the mountain valleys with churches ringing and sheep in the meadows, and the awesome peaks of the Dolomite mountains towering beyond.We spent several days exploring the mountain villages and each other&apos;s hearts. And when the day came for her to return, I took her to a train station in a nearby village, and we said goodbye. It was very sad to be going our own ways again. With tears in my eyes, I got on a bus and headed for the train station in Bressanone. During the short 40-minute bus ride, I fell asleep. And while I slept, I had a dream in which I could hear this song, complete with the words and music. When I awoke, I got off the train and went to the nearest coffee shop to write the words and music on a napkin, so I would not forget.It was years later when I finally recorded the song. I will always have a place in my heart for her... and for that village... and for this song.Thank you for listening. Now... off to bed with you!!!:-)Matthew 参考链接故事","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"java 算法 （排序算法 冒泡排序）","date":"2017-02-23T15:02:39.000Z","path":"2017/02/23/javahigh/","text":"题外话 ps:今天真的是被git弄的稀里糊涂了一天，弄到现在还在实验室，我都怀疑自己的认真劲头了😂。 以前觉得自己没有做技术的耐性，无法静静的呆在自己的电脑前。那个时候坐在电脑前都会流眼泪，那个时候就对自己说：是的我不合适做技术，然而读研的路上感觉自己的性格改变了很多，不敢说非常踏实，但是目前来说，静静地看着技术文档和书籍，常常能获得快感，就像现在已经过了12点，我在“奋笔疾书”。解决bug的时候有那么一丝丝成就感，不知道是不是自己越来越适合做技术了，感觉自己每天过的越来越充实和快乐，只要今天的自己比昨天的自己更强大。 正题 排序算法 分类 交换排序 冒泡排序 快速排序 选择排序 选择排序 堆排序 插入排序 插入排序 shell排序 合并排序 冒泡排序（Bubble Sort）思想：冒泡排序需要遍历多遍数组，在每次遍历🀄比较相邻的元素。较小值像“气泡”一样上浮，较大的值沉向底部。步骤： 对数组中的各个数据，依次比较相邻的两个数据大小 如果前面的数据大于后面的数据，就交换两个数据。这样可以找出最小的。 依次用同样的方法，排序。时间：$\\dfrac {n\\left( n-1\\right) } {2}=O\\left( n^{2}\\right)$ 123456789101112131415161718192021222324252627282930313233主要代码：package sort;import UtilAlgorithm.Main;import UtilAlgorithm.Util;/** * Created by xiezhanghua on 2017/2/23. */public class Sort &#123; public static int[] bubleSort(int[] arr) &#123; System.out.println(&quot;冒泡排序前的数组为：&quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; System.out.println(&quot;&quot;); System.out.println(&quot;冒泡排序后的数组为：&quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125; return arr; &#125;&#125; 参考书籍和链接 《java 常用算法手册》 《java 语言程序设计》","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"开发中的bug","date":"2017-02-22T05:40:48.000Z","path":"2017/02/22/bug/","text":"问题：解决maven 更新慢的问题系统：Mac解决方向：使用阿里镜像方法： cd /usr/local/Cellar/maven/3.3.9/libexec/conf(brew install maven 的路径) subl setting.xml (subl 在这里是使用sublime text 打开 文件 open -a ) 将下面代码替换setting.xml中的 mirrors 1234567891011121314151617181920&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; matlab语法：imshow ( f, G) imshow (f, [low high]) imshow (f, [ ])说明：G是显示该图像的灰度级数； 小于或等于low的值都显示为黑色，大于或等于high的值都显示为白色。 [ ]自动将变量low设置为f的最小值，将high设置为f的最大值。 idea 技巧快速生成123public static void main(Sting[] agrs) &#123; &#125; 解决方法：在idea中输入psvm，然后按tab就可以自动生成 快速生成1System.out.println(); 解决方法：在idea中输入sout，然后按tab就可以自动生成 快速生成构造函数123456789class Dog &#123; String name; String says; &lt;!-- public Dog(String name, String says) &#123; this.name = name; this.says = says; 这里被注释掉的是构造函数，如果快速生产 &#125; --&gt; &#125; 解决方法： 在idea中选择code-&gt;generator 或者直接按下control+n（Mac环境下） 参考链接blog1 hexo 中写数学公式 Latexps:今天本来是准备动手看算法方面的东西，然后准备使用hexo看下数学公式怎么显示。然后就出现问题了，显示的时候会出现很多莫名的问题。重要的是我都没有数学编辑器，😂话说论文也要写了啊。所以开始找个好一点的数学编辑器，然后在b呼中找到了。那么问题来了，是时候写一篇练习Latex的文档了。 submlim + Latexb呼推荐解决方法：就是把主题中的配置文件中的 mathjax: true 设置为true 一些小概念语法糖(Syntactic sugar)：是由Peter J. Landin(和图灵一样的天才人物，是他最先发现了Lambda演算，由此而创立了函数式编程)创造的一个词语，它意指那些没有给计算机语言添加新功能，而只是对人类来说更“甜蜜”的语法。 brew 和 brew caskbrew是从下载源码解压然后./configure &amp;&amp; make install,同时会包含相关依赖库。并自动配置好各种环境变量，而且易于卸载。 brew cask 是已经编译好的应用包，仅仅是下载解压，放在统一的目录中（/opt/homebrew-cask/Caskroo,），省掉了自己去下载 解压 安装步骤。","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"数据库学习笔记二","date":"2017-02-19T14:45:29.000Z","path":"2017/02/19/mysql2/","text":"Mysql 视图概念： 视图可以包含表中的所有列，或者仅包含选定的列。视图可以创建自一个或者多个表，这取决于创建该视图的 SQL 语句的写法。视图，是一种虚拟的表，数据库只存放了视图的定义，并没有存放视图中的数据。优点：用户可以不用看到整个数据库表中的数据，而只关心对自己有用的数据即可。 作用： 简单性：所见即所需 安全性：授权 逻辑数据独立性：程序与数据库独立 视图与查询的区别： 视图和查询都是用由sql语句组成,这是他们相同的地方,但是视图和查询有着本质区别：它们的区别在于： 存储上的区别：视图存储为数据库设计的一部分,而查询则不是 更新限制的要求不一样要注意：因为视图来自于表,所以通过视图可以间接对表进行更新,我们也可以通过update语句对表进行更新,但是对视图和查询更新限制是不同的, 排序结果：通过sql语句,可以对一个表进行排序,而视图则不行。 Mysql 存储过程存储过程和存储函数是一些被用户定义的SQL语句集合，经编译后存储在数据库。用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。其具有执行速度快，提高系统性能，确保数据库安全等诸多优点。 优点： 存储过程允许标准组件式编程 存储过程能够实现较快的执行速度 存储过程能够减少网络流量 存储过程可被作为一种安全机制来充分利用 参考书籍和链接《Mysql快速入门》博客一博客二","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"数据库学习笔记一","date":"2017-02-19T14:45:29.000Z","path":"2017/02/19/transction/","text":"连接查询连接是把不同表的记录连到一起的最普遍的方法。 内连接：最普遍的连接类型，而且是最匀称的，因为它们要求构成连接的每一个部分的每个表匹配，不匹配的行将被排除。 外连接：使用outer join关键字将两个表连接起来。外连接生成的结果集不仅包括符合链接条件的行数据，而且还包括左表（左外连接）、右表（右边连接时的表）或两边链接表（全外连接时的表）中所有的数据行。 合并查询合并查询结果是将多个select语句的查询结果合并在一起。因为某种情况下，需要将几个select语句查询出来的结果合并起来显示。合并查询结果使用union和union all关键字。union关键字是将所有的查询结果合并在一起，然后去除相同记录；而union all关键字则只是简单地将结果合并在一起。 索引我们常见的数据库系统，其索引使用的数据结构多是B-Tree或者B+Tree。例如，MsSql使用的是B+Tree，Oracle及Sysbase使用的是B-Tree。所以在最开始，简单地介绍一下B-Tree。B-Tree 概念：索引是对数据库表中一个或多个列的值进行排序的结构。优点：在查询过程中使用索引，会提高数据库查询效率，应用索引来查询数据库中的内容，可以减少查询的次数，从而到达查询优化目的。缺点：创建索引和维护需要耗费时间，并且该耗费时间与数据量的大小成正比；另外，索引需要占用物理空间，给数据的维护造成很多麻烦。 索引分类 普通索引：不应用任何约束的索引，该索引可以在任何数据类型中创建。 唯一索引：使用UNIQUE参数可以设置唯一索引。该索引值必须唯一。主键是一种特殊的唯一索引。 全文索引：全文索引智能创建在CHAR、VARCHAR或者TEXT类型的字段上。查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。 单列索引：单列索引只对应一个字段的索引。 多列索引：在表的多个字段上创建一个索引。 事务处理 概念和技术事务处理系统的基本抽象：现实的状态通过一个称为数据库的抽象表示，现实状态的转变通过执行一个称为事务的执行过程来反映，他改变数据库的状态。P1 这里在介绍下事务的概念以及事务的ACID特性数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。ACID 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。 参考书籍和链接《事务处理 概念和技术》《Mysql快速入门》详解SQL Server连接（内连接、外连接、交叉连接）索引","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"事务处理","slug":"事务处理","permalink":"http://yoursite.com/tags/事务处理/"}]},{"title":"学习资料记录","date":"2017-02-17T06:31:59.000Z","path":"2017/02/17/reading/","text":"学会使用搜索引擎学会使用搜索引擎十大高明的Google搜索技巧 提问敬请:智慧的提问智慧的提问 这里记录下每个阶段的学习资料 ##java 多线程和并发java 并发性和多线程并发编程网JDK8JDK6 @SpringBootApplication的使用 mysql 忘记 root 密码《java编程思想》 纸质书籍 web《java web 开发》 spring《Spring实战》 Mysql《Mysql快速入门》 纸质书籍《事务处理的技术和概念》 这个学习的文档使电子书籍 操作系统《计算机操作系统》陈渝教学视频 编译原理","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"reading","slug":"reading","permalink":"http://yoursite.com/tags/reading/"}]},{"title":"泰国游记原稿","date":"2017-02-07T03:11:48.000Z","path":"2017/02/07/thailand01/","text":"ps：最近在忙于学业，就一直没有整理我的游记，这里先贴出来一些原始稿件，对大家有帮助 泰国游记 第一天1.16故事附加：泰国留学生抵达（廊曼机场）午餐当地、meji牛奶下午卧佛寺、拍照（国王丧期，国民祭祀）晚上考山路、酒吧（center khao saim）、小吃、砍价、买东西教训：坑货司机，400RMB关键词：taxi、便宜、彩色（国王颜色，待查证） 、舞蹈中午吃的：鸡腿、牛肉串（不知道叫什么），蔬菜生的配肉和酱，这个酱好辣啊很多材料都没怎么处理，总共510B下午吃的：路边各种免费饮料，应该是国王祭祀期间送的、芒果（不是很甜100B）晚上吃的：榴莲180B（第一次吃😂😂，还挺好吃的））、热带水果拼盘50B两份（火龙果、芒果、木瓜）、pad thai50B（虾仁，加一句，这边的虾不要钱的样子，什么里面都加）、椰奶冰淇淋，有椰肉好吃的50B，酒吧各种好吃的1470B建议：1.酒吧要选人多的，有欧洲人莫名就起舞了😂😂2.榴莲要选软的，颜色偏淡，饱满的3.曼谷check in 3点以后，自己定的民宿可以联系房东，（airbnb上预定的）4.建议住民宿，房东让我们早check in，让我们寄存东西，免费送我们去机场，常常受到我们的电话骚扰。5.司机巨坑，建议能不上高速就不上高速，过高速的费用都是我们出（有点贵🌚），建议接机和包车6.大皇宫8:30-3:30，我们去的时候太晚了，没办法去大皇宫，很遗憾😭😭😭7.国际航空挺稳定，位子也还挺宽的。泰国国内航空位子窄。故事1.老夫妻的舞蹈2.护照丢失奇案，主人公（汪小明） 第二天1.17去机场：100B出行：门口出租都是一口价，不打表，我们包车SUV（260B到酒店）建议：1.正规酒店2点check in，（携程上预定的）可以寄存在东西，用护照。提前check in收费400泰铢2.虫子多3.吃饭4.中午清曼寺，静坐参悟，融入5.check in6.lila按摩店押金600B7.各种寺庙8.坐车到瓦洛洛市场（垃圾）120B草莓150B、菠萝65B、香肠15B9.坐车到苏打曼市场（100B）10.晚饭酒109B，烧烤400B，饭530B11.坐车回酒店150B12.吹风机押金300B袁枫林和陶轩 1.18地点：清迈1.接车到蝴蝶园2.蝴蝶园到激流勇进（很好玩）3.激流勇进照片，工作人员拍（150一张），建议带两套衣服包括内裤，做好防晒，这边711美好的防晒，去boots买4.午餐，自助餐（水好喝，蔬菜沙拉好吃，强推，味道极好一点涩味都没有，超级爽口），套餐内5.骑大象（没什么意思）6.丛林飞跃（19），很好玩，工作人员会拍照，出门在外记得熬pose（150一张），记得带u盘，可以拷贝7.竹筏超级无聊，还要求小费建议：1.5:00小卖部关门，这边游玩身体很渴2.防晒 早饭：157B晚饭：2550B故事：营救翻船救人，路上混战（champion被围攻，就是我们🙈）goodteam陶轩、老张尿尿在佛祖旁边梗：老司机（xzh）老妈妈（wm，老张）漂酿（袁枫林，zqr）小女孩问（xzh）性别袁枫林裤子开档（被汪明拧坏的 1.19地点：清迈1.早饭：泡面便宜又好吃，红色的味道有点怪159B2.双条车包车到双龙寺门票（50B）电梯20B，30B门票，花和蜡烛（20B）3.午餐：780B4.清迈大学，车票60B5.塔佩门shop336元加6.包车付钱：1400B7.飞机清迈～曼谷，曼谷～普吉（一路跑步）故事：祈祷汪明求签差点误机液体太重不能上飞机（托运）飞奔的✈️ 1.201.6:20起床坐车去斯米兰岛（一日游团）飞猪上订的2.岛上交通基本走环岛线路，从机场到酒店以及九点到机场都要将近2小时（刚好补觉了）3.建议：跟团不错，就是常遇到中国人😂😂，比如你在车上睡觉，她在看喜羊羊与灰太狼🌚（山寨机的外音无解）4.早餐自助，就餐后吃晕船药，会发药和黄色橡胶圈（队伍标志，靠这个区分）5.登船去斯米兰岛，斯米兰岛9岛，我们玩4个岛，两个浮潜点（7、4）先去主岛，那边吃午饭可以在间隙拍照，海水很蓝，风景很好再去第一个浮潜点7，有很多漂亮的鱼（强推）建议记得带防水套，防水套，防水套。时间半小时然后去第二个浮潜点4，没什么东西看，时间半小时最后在岛上，会给1个半小时拍照时间，岛上风景超级美，海水比第一个海蓝岛上人多，建议在船离开案边间隙拍照，宽阔海景一览无遗。1个半小时拍照时间江西冷：low，衣服750B晚饭：2150B建议：1.带毛巾、泳裤、换洗衣服裤子。每去一个岛船员都会给我们水果和饮料，最后还有饼干。船员消费是每个人50B。 1.211.早上8:15出发到码头2.坐船半小时到岛珊瑚岛3.岛上玩香蕉船还可以（800B），飞伞（800B），同学说不好玩，吃午饭，玩水4.坐船去皇权岛深潜（2100B）或者套餐，好玩，海底拍照，租相机（2000B）两人5.钓鱼，日落。6.晚餐故事：袁和周半夜买药，感动）T_T美人鱼沙雕 1.221.普吉—曼谷2.美功铁道市场3.安帕瓦水上市场买买买，吃吃吃，比西塘好 1.231.机场寄存行李2.机场大巴6号门a1去BTS3.BTS去siam 泰国印象1.垃圾桶少，但是路上垃圾不是很多2.斑马线、红绿灯不多，这里夸下泰国司机，路人示意要过马路，司机会主动让行人3.车速慢中午：百香果、芒果冰沙45Bthe chef 800B，鱿鱼丝4.夜场坑5.国内机可能早飞6.机场可寄存东西75B一件7.6号门A1 买东西：雪肌精乳液欧莱雅口红 唇釉V103鼻通肩痛祛疤烟","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"travel","slug":"travel","permalink":"http://yoursite.com/tags/travel/"},{"name":"thailand","slug":"thailand","permalink":"http://yoursite.com/tags/thailand/"}]},{"title":"泰国游记序言","date":"2017-02-04T15:44:55.000Z","path":"2017/02/04/thailand00/","text":"这是一次真正意义上的说走就走的旅行，当我看到我同门师弟（其实也不算师弟，我们同届，只是他晚来几天^-^）在买飞机票的时候我就好奇的问了句“去哪里玩吗？”同时回了句“我也去可以？”。就这样的两个问句开始我2017年的第一次旅游，同时也是我的第一次出国游，同时也完成了我许许多多的第一次。最最重要的使这是我第一次写游记，本来没这种兴趣的，但是不知道怎么就在手机上写了一些简单的记录，回来了也就想着干脆写游记吧。毕竟这一路上自己也遇到了一些坑，就当给别人一些参考也好，而且一边写着一边回忆起旅游的乐事，真的很有意思，有的时候都会笑出来声来。 首先简单介绍一下一起出行的6个人。 从前往后介绍：一排左一是我们的财政大臣，所有公费都放在这个boy手上，办事沉稳一排右一是我们的欢乐使者，气氛莫名尴尬的时候只需要他发声立马暖场二排左一和右一是太阳伞CP，只要有太阳自动组合三排左一和右一是绯闻CP，学校到泰国到学校都是绯闻CP那么问题来了，那个才是真的我 再简单介绍一下我们的行程：旅游方式：自助游+两个一日团行程：为期8天，旅游城市：清迈，普吉和曼谷住宿：名宿和酒店出行方式：飞机，出租，包车，船和嘟嘟车（凸凸车）电话：happy卡花费：旅游+购物 7000+RMB","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"travel","slug":"travel","permalink":"http://yoursite.com/tags/travel/"},{"name":"thailand","slug":"thailand","permalink":"http://yoursite.com/tags/thailand/"}]},{"title":"小章鱼2017年计划","date":"2017-01-14T15:53:55.000Z","path":"2017/01/14/2017plan/","text":"前言 2016年已经过去了。 2017年计划非技术文艺片 至少观看两部话剧(周五晚上)，话剧表演艺术以及观众对的素质，是我深深的爱上了话剧这种艺术形式 至少观看六部电影 至少看十本课外书，生活不止眼前的苟且，还有诗和远方的田野。 去上海野生动物园(携程买)，喜欢看BBC对于动物纪录片的记录。 找有意思的地方，逛逛街，拍照(周末)，陪她走过尘世的美好。 给对方写信(要真诚)，把真情融入文字中。 励志片(祝福她考研成功) 每天背单词(互相打卡)加油！ 坚定她考研信念，不放弃，给她鼓励。 最终目标 帮助她考上研究生，然后一起去台湾或者云南玩耍。","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"paln","slug":"paln","permalink":"http://yoursite.com/tags/paln/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"hexo 安装第一篇","date":"2017-01-12T15:23:41.000Z","path":"2017/01/12/creathexo/","text":"第一步安装 nodenode 第二步安装 gitgit 第三部安装 hexo$ npm install -g hexo-cli 第四步创建hexo文件夹‘hexo init’这里有一个坑的地方在于使用的使npm安装的初始theme的时候很慢，你耐心等待就好了 第五步安装hexo依赖npm install 第六步创建hexo文件夹所在目录执行hexo ghexo s可以在localhost：4000访问到页面这里有一个坑的地方是如果以上步骤都对的话，如果访问4000端口没有页面，那就你就是安装了福新阅读器，不要问我问什么知道执行hexo s -p 5000 本地的介绍到这里 参考链接hexo官网博客","tags":[{"name":"小章鱼","slug":"小章鱼","permalink":"http://yoursite.com/tags/小章鱼/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Markdown 学习笔记","date":"2017-01-12T07:14:01.000Z","path":"2017/01/12/start/","text":"段落第一段第二段第三段源代码 # 第一段 ## 第二段 ### 第三段 列表 苹果 香蕉 菠萝源代码123* 苹果* 香蕉* 菠萝 引用、斜体、加粗 天空没有鸟的痕迹，但我已飞过。 –泰戈尔源代码&gt; _天空没有**鸟**的痕迹，但我已飞过_。 --泰戈尔 代码块1234567891011121314ul &#123; margin: 0 0; padding: 0 0; list-style-type: none;&#125;li &#123; float: right; width: 80px; height: 40px; margin-right: 5%; margin-bottom: 10px; line-height: 40px; text-align: center;&#125; 源代码(css ul { margin: 0 0; padding: 0 0; list-style-type: none; } li { float: right; width: 80px; height: 40px; margin-right: 5%; margin-bottom: 10px; line-height: 40px; text-align: center; }) 分割线 源代码 - - - 链接i am 404i am baidu源代码 [i am 404](https://twitter.com/Tracy_xzh) [i am baidu](https://www.baidu.com) 参考链接链接","tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"},{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]}]